<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cradle Adventure: Path of Sacred Valley</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            border: 3px solid #333;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            width: 100%;
            height: 100vh;
            max-width: 100%;
            max-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            font-size: 14px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .healthBar {
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid #fff;
            margin: 5px 0;
            position: relative;
        }

        .healthFill {
            height: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }

        .madraBar {
            width: 200px;
            height: 15px;
            background-color: #222;
            border: 2px solid #66f;
            margin: 5px 0;
            position: relative;
        }

        .madraFill {
            height: 100%;
            background: linear-gradient(90deg, #0066ff, #00ccff);
            transition: width 0.3s;
        }

        #combatUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: white;
            display: none;
            pointer-events: none;
        }

        .combatBars {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .fighterInfo {
            text-align: center;
        }

        .comboCounter {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #ff0;
            text-shadow: 3px 3px 0px #f00;
            display: none;
        }

        #dialogue {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ff88;
            border-radius: 10px;
            padding: 15px 25px;
            color: white;
            max-width: 80%;
            display: none;
            text-align: center;
            font-size: 16px;
            z-index: 500;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .floatingText {
            position: absolute;
            color: #ff0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0px black;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            to {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        .screenFlash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            opacity: 0;
            pointer-events: none;
        }

        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            top: 0;
            pointer-events: none;
            display: none;
        }
        
        .touch-zone {
            position: absolute;
            pointer-events: auto;
            opacity: 0.3;
            transition: opacity 0.2s;
        }
        
        .touch-zone:active {
            opacity: 0.6;
        }
        
        #virtualJoystick {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
        }
        
        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
            pointer-events: none;
        }
        
        .action-button {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 1px 1px 0 black;
        }
        
        #actionA {
            bottom: 100px;
            right: 140px;
        }
        
        #actionB {
            bottom: 50px;
            right: 80px;
        }
        
        #actionSpecial {
            bottom: 150px;
            right: 80px;
            background: rgba(0, 100, 255, 0.3);
        }
        
        #combatMoveLeft {
            bottom: 50px;
            left: 50px;
            width: 80px;
            height: 80px;
        }
        
        #combatMoveRight {
            bottom: 50px;
            left: 150px;
            width: 80px;
            height: 80px;
        }
        
        .mobile-instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            text-shadow: 2px 2px 0 black;
            pointer-events: none;
        }

        #advancementNotice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0;
            font-size: 36px;
            text-shadow: 3px 3px 0px #f00;
            display: none;
            text-align: center;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 10px;
            color: white;
            font-size: 12px;
            max-width: 200px;
        }

        .control-line {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .key {
            color: #00ff88;
            font-weight: bold;
        }

        .help-reminder {
            text-align: center;
            margin-top: 5px;
            font-style: italic;
            opacity: 0.7;
        }

        #fullscreenBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            color: #00ff88;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        #controlsToggle {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            color: #00ff88;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .controls-hint {
            position: absolute;
            bottom: 50px;
            left: 10px;
            color: #00ff88;
            font-size: 14px;
            animation: pulse 2s infinite;
        }

        #fullControls {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ff88;
            border-radius: 15px;
            padding: 30px;
            color: white;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .close-controls {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #ff0000;
        }

        .control-section {
            margin: 20px 0;
        }

        .control-section h3 {
            color: #00ff88;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 5px;
            margin-bottom: 15px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
        }

        .control-key {
            background: rgba(0, 255, 136, 0.2);
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
            color: #00ff88;
        }

        #saveMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #fff;
            padding: 20px;
            color: white;
            text-align: center;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <button id="fullscreenBtn" onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
        
        <div id="ui">
            <div>Wei Shi Lindon - <span id="advancement">Unsouled</span></div>
            <div class="healthBar">
                <div class="healthFill" id="playerHealth" style="width: 100%"></div>
            </div>
            <div class="madraBar">
                <div class="madraFill" id="playerMadra" style="width: 100%"></div>
            </div>
            <div>Madra Collected: <span id="madraCount">0</span></div>
            <div>Combat Wins: <span id="winCount">0</span></div>
        </div>

        <div id="combatUI">
            <div class="combatBars">
                <div class="fighterInfo">
                    <h3>LINDON</h3>
                    <div class="healthBar" style="width: 300px">
                        <div class="healthFill" id="combatPlayerHealth" style="width: 100%"></div>
                    </div>
                    <div class="madraBar" style="width: 300px">
                        <div class="madraFill" id="combatPlayerMadra" style="width: 100%"></div>
                    </div>
                </div>
                <div class="fighterInfo">
                    <h3 id="enemyName">ENEMY</h3>
                    <div class="healthBar" style="width: 300px">
                        <div class="healthFill" id="combatEnemyHealth" style="width: 100%; background-color: #f00"></div>
                    </div>
                </div>
            </div>
            <div class="comboCounter" id="comboCounter">COMBO x<span id="comboCount">0</span></div>
        </div>

        <div id="dialogue"></div>
        <div class="screenFlash" id="screenFlash"></div>
        <div id="advancementNotice"></div>

        <div id="instructions">
            <div id="explorationInstructions">
                <div class="control-line">
                    <span>Move:</span>
                    <span class="key">WASD/Arrows</span>
                </div>
                <div class="control-line">
                    <span>Interact:</span>
                    <span class="key">SPACE</span>
                </div>
                <div class="control-line">
                    <span>Save:</span>
                    <span class="key">F5</span>
                </div>
                <div class="control-line">
                    <span>Load:</span>
                    <span class="key">F9</span>
                </div>
                <div class="control-line">
                    <span>Save Menu:</span>
                    <span class="key">M</span>
                </div>
                <div class="help-reminder">Press ? for Full Help</div>
            </div>
            <div id="combatInstructions" style="display: none">
                <div class="control-line">
                    <span>Move:</span>
                    <span class="key">A/D</span>
                </div>
                <div class="control-line">
                    <span>Punch:</span>
                    <span class="key">J</span>
                </div>
                <div class="control-line">
                    <span>Kick:</span>
                    <span class="key">K</span>
                </div>
                <div class="control-line">
                    <span>Block:</span>
                    <span class="key">L (Hold)</span>
                </div>
                <div class="control-line">
                    <span>Empty Palm:</span>
                    <span class="key">SPACE</span>
                </div>
                <div class="help-reminder">Press ? for Full Help</div>
            </div>
        </div>
        
        <button id="controlsToggle" onclick="toggleControls()">Controls (C)</button>
        
        <div class="controls-hint" id="controlsHint">
            Press C for Controls
        </div>
        
        <div id="fullControls">
            <span class="close-controls" onclick="hideControls()">√ó</span>
            <h2>Sacred Artist Control Manual</h2>
            
            <div class="control-section">
                <h3>üéÆ Basic Movement</h3>
                <div class="control-item">
                    <span>Move</span>
                    <span class="control-key">WASD / Arrow Keys</span>
                </div>
                <div class="control-item">
                    <span>Interact/Talk</span>
                    <span class="control-key">SPACE</span>
                </div>
                <div class="control-item">
                    <span>Run (with certain paths)</span>
                    <span class="control-key">SHIFT</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>‚öîÔ∏è Combat Controls</h3>
                <div class="control-item">
                    <span>Move Left/Right</span>
                    <span class="control-key">A / D</span>
                </div>
                <div class="control-item">
                    <span>Punch</span>
                    <span class="control-key">J</span>
                </div>
                <div class="control-item">
                    <span>Kick</span>
                    <span class="control-key">K</span>
                </div>
                <div class="control-item">
                    <span>Block</span>
                    <span class="control-key">L (Hold)</span>
                </div>
                <div class="control-item">
                    <span>Empty Palm (Uses Madra)</span>
                    <span class="control-key">SPACE</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>üíæ System Controls</h3>
                <div class="control-item">
                    <span>Quick Save</span>
                    <span class="control-key">F5</span>
                </div>
                <div class="control-item">
                    <span>Quick Load</span>
                    <span class="control-key">F9</span>
                </div>
                <div class="control-item">
                    <span>Save Menu</span>
                    <span class="control-key">M</span>
                </div>
                <div class="control-item">
                    <span>Toggle Controls</span>
                    <span class="control-key">C</span>
                </div>
                <div class="control-item">
                    <span>Close Menus</span>
                    <span class="control-key">ESC</span>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px; color: #00ff88;">
                <em>"The dragon advances through understanding."</em>
            </div>
        </div>
        
        <div id="mobileControls">
            <div id="explorationControls">
                <div id="virtualJoystick" class="touch-zone">
                    <div id="joystickKnob"></div>
                </div>
                <div id="actionA" class="action-button touch-zone">Talk</div>
                <div class="mobile-instructions">Move: Left side | Interact: Right side</div>
            </div>
            
            <div id="combatControls" style="display: none;">
                <div id="combatMoveLeft" class="action-button touch-zone">‚Üê</div>
                <div id="combatMoveRight" class="action-button touch-zone">‚Üí</div>
                <div id="actionB" class="action-button touch-zone">Punch</div>
                <div id="actionA" class="action-button touch-zone">Kick</div>
                <div id="actionSpecial" class="action-button touch-zone">Palm</div>
                <div class="mobile-instructions">Tap buttons to fight!</div>
            </div>
        </div>
        
        <div id="saveMenu">
            <h2 style="margin-top: 0;">SAVE MENU</h2>
            <div id="saveSlots" style="margin: 20px 0;"></div>
            <div style="margin-top: 20px;">
                <button onclick="closeSaveMenu()" style="padding: 10px 20px; font-size: 16px; cursor: pointer;">Close (ESC)</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            const aspectRatio = 4 / 3;
            let newWidth, newHeight;
            
            if (containerWidth / containerHeight > aspectRatio) {
                newHeight = containerHeight;
                newWidth = newHeight * aspectRatio;
            } else {
                newWidth = containerWidth;
                newHeight = newWidth / aspectRatio;
            }
            
            canvas.width = 800;
            canvas.height = 600;
            
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
            
            canvas.style.position = 'absolute';
            canvas.style.left = '50%';
            canvas.style.top = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const game = {
            mode: 'exploration',
            player: {
                x: 400,
                y: 300,
                health: 100,
                maxHealth: 100,
                madra: 100,
                maxMadra: 100,
                madraCollected: 0,
                advancement: 'Unsouled',
                speed: 3,
                combatWins: 0,
                techniques: ['punch', 'kick', 'emptyPalm']
            },
            camera: {
                x: 0,
                y: 0
            },
            combat: {
                playerX: 200,
                playerY: 400,
                playerVelY: 0,
                playerState: 'idle',
                playerFacing: 1,
                enemyX: 600,
                enemyY: 400,
                enemyHealth: 100,
                enemyMaxHealth: 100,
                enemyState: 'idle',
                enemyType: null,
                combo: 0,
                lastHit: 0,
                blockActive: false
            },
            world: {
                width: 1600,
                height: 1200,
                tiles: [],
                entities: [],
                npcs: []
            },
            saveSlot: 1,
            lastSaveTime: 0
        };

        let saveMethod = 'none';
        
        function testSaveMethod() {
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                saveMethod = 'localStorage';
                console.log('Using localStorage for saves');
            } catch (e) {
                saveMethod = 'memory';
                console.log('Using memory saves (temporary)');
            }
        }
        
        const memorySaves = {};
        
        function saveGame(slot = game.saveSlot) {
            const saveData = {
                player: {
                    x: game.player.x,
                    y: game.player.y,
                    health: game.player.health,
                    maxHealth: game.player.maxHealth,
                    madra: game.player.madra,
                    maxMadra: game.player.maxMadra,
                    madraCollected: game.player.madraCollected,
                    advancement: game.player.advancement,
                    speed: game.player.speed,
                    combatWins: game.player.combatWins,
                    techniques: [...game.player.techniques]
                },
                world: {
                    entities: game.world.entities.map(e => ({
                        type: e.type,
                        x: e.x,
                        y: e.y,
                        collected: e.collected,
                        enemyType: e.enemyType,
                        health: e.health
                    }))
                },
                timestamp: Date.now(),
                playTime: Date.now() - game.lastSaveTime
            };
            
            try {
                if (saveMethod === 'localStorage') {
                    localStorage.setItem(`cradleSave_${slot}`, JSON.stringify(saveData));
                } else {
                    memorySaves[`cradleSave_${slot}`] = JSON.stringify(saveData);
                }
                
                showSaveNotification('Game Saved!');
                game.lastSaveTime = Date.now();
                
                if (saveMethod === 'memory') {
                    offerDownloadSave(saveData, slot);
                }
                
                return true;
            } catch (e) {
                console.error('Save error:', e);
                showSaveNotification('Save Failed! Check browser settings.', true);
                return false;
            }
        }
        
        function offerDownloadSave(saveData, slot) {
            const dataStr = JSON.stringify(saveData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `cradle_save_slot_${slot}.json`;
            
            const downloadPrompt = document.createElement('div');
            downloadPrompt.style.cssText = `
                position: absolute;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: #000;
                border: 2px solid #0f0;
                padding: 10px;
                color: #0f0;
                text-align: center;
                z-index: 1000;
            `;
            downloadPrompt.innerHTML = `
                <p>Browser storage unavailable!</p>
                <button onclick="this.parentElement.querySelector('a').click()" style="padding: 5px 10px; cursor: pointer;">Download Save File</button>
                <button onclick="this.parentElement.remove()" style="padding: 5px 10px; margin-left: 10px; cursor: pointer;">Cancel</button>
            `;
            downloadPrompt.appendChild(link);
            document.getElementById('gameContainer').appendChild(downloadPrompt);
            
            setTimeout(() => downloadPrompt.remove(), 10000);
        }

        function loadGame(slot = 1) {
            try {
                let saveData;
                
                if (saveMethod === 'localStorage') {
                    saveData = localStorage.getItem(`cradleSave_${slot}`);
                } else {
                    saveData = memorySaves[`cradleSave_${slot}`];
                }
                
                if (!saveData) return false;
                
                const data = JSON.parse(saveData);
                
                Object.assign(game.player, data.player);
                
                generateWorld();
                
                if (data.world && data.world.entities) {
                    game.world.entities = game.world.entities.filter(entity => {
                        const savedEntity = data.world.entities.find(e => 
                            e.type === entity.type && 
                            Math.abs(e.x - entity.x) < 50 && 
                            Math.abs(e.y - entity.y) < 50
                        );
                        
                        if (savedEntity) {
                            if (savedEntity.type === 'madra' && savedEntity.collected) {
                                return false;
                            }
                            if (savedEntity.type === 'enemy' && !savedEntity.health) {
                                return false;
                            }
                            if (savedEntity.type === 'enemy') {
                                entity.health = savedEntity.health;
                            }
                        }
                        return true;
                    });
                }
                
                game.lastSaveTime = Date.now();
                updateUI();
                showSaveNotification('Game Loaded!');
                return true;
            } catch (e) {
                console.error('Load error:', e);
                showSaveNotification('Load Failed!', true);
                return false;
            }
        }

        function getSaveInfo(slot) {
            try {
                let saveData;
                
                if (saveMethod === 'localStorage') {
                    saveData = localStorage.getItem(`cradleSave_${slot}`);
                } else {
                    saveData = memorySaves[`cradleSave_${slot}`];
                }
                
                if (!saveData) return null;
                
                const data = JSON.parse(saveData);
                return {
                    advancement: data.player.advancement,
                    madraCollected: data.player.madraCollected,
                    combatWins: data.player.combatWins,
                    timestamp: data.timestamp,
                    playTime: data.playTime
                };
            } catch (e) {
                return null;
            }
        }

        function deleteSave(slot) {
            try {
                if (saveMethod === 'localStorage') {
                    localStorage.removeItem(`cradleSave_${slot}`);
                } else {
                    delete memorySaves[`cradleSave_${slot}`];
                }
                showSaveNotification('Save Deleted!');
                return true;
            } catch (e) {
                return false;
            }
        }

        function showSaveNotification(text, isError = false) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${isError ? '#ff0000' : '#00ff00'};
                color: black;
                padding: 10px 20px;
                font-size: 20px;
                font-weight: bold;
                border: 2px solid white;
                z-index: 1000;
            `;
            notification.textContent = text;
            document.getElementById('gameContainer').appendChild(notification);
            
            setTimeout(() => notification.remove(), 1500);
        }

        function autoSave() {
            if (game.mode === 'exploration' && Date.now() - game.lastSaveTime > 30000) {
                saveGame();
            }
        }

        const keys = {};
        const touches = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            isMoving: false,
            joystickActive: false
        };
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === 'F5') {
                e.preventDefault();
                saveGame();
            }
            if (e.key === 'F9') {
                e.preventDefault();
                loadGame(game.saveSlot);
            }
            if (e.key.toLowerCase() === 'm' && game.mode === 'exploration') {
                e.preventDefault();
                openSaveMenu();
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                closeSaveMenu();
                hideControls();
            }
            if (e.key.toLowerCase() === 'c') {
                e.preventDefault();
                toggleControls();
            }
            
            if (['w', 'a', 's', 'd', 'j', 'k', 'l', ' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            e.preventDefault();
        });
        
        function toggleControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv && controlsDiv.style.display === 'block') {
                hideControls();
            } else {
                showControls();
            }
        }
        
        function showControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv) {
                controlsDiv.style.display = 'block';
                game.paused = true;
                const hint = document.getElementById('controlsHint');
                if (hint) hint.style.display = 'none';
            }
        }
        
        function hideControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv) {
                controlsDiv.style.display = 'none';
                game.paused = false;
            }
        }
        
        window.toggleControls = toggleControls;
        window.showControls = showControls;
        window.hideControls = hideControls;
        
        let firstInteraction = true;
        window.addEventListener('keydown', () => {
            if (firstInteraction) {
                firstInteraction = false;
                setTimeout(() => {
                    const hint = document.getElementById('controlsHint');
                    if (hint) hint.style.display = 'none';
                }, 5000);
            }
        });
        
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            touches.startX = x;
            touches.startY = y;
            touches.currentX = x;
            touches.currentY = y;
            
            if (game.mode === 'exploration') {
                if (x < canvas.width / 3) {
                    touches.joystickActive = true;
                    touches.isMoving = true;
                }
                else if (x > canvas.width * 2/3) {
                    keys[' '] = true;
                    setTimeout(() => keys[' '] = false, 100);
                }
            } else if (game.mode === 'combat') {
                if (x < canvas.width / 4) {
                    keys['a'] = true;
                } else if (x > canvas.width * 3/4) {
                    keys['d'] = true;
                } else if (y < canvas.height / 2) {
                    keys[' '] = true;
                } else {
                    if (x < canvas.width / 2) {
                        keys['j'] = true;
                    } else {
                        keys['k'] = true;
                    }
                }
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (!touches.isMoving) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touches.currentX = touch.clientX - rect.left;
            touches.currentY = touch.clientY - rect.top;
            
            if (touches.joystickActive && game.mode === 'exploration') {
                const dx = touches.currentX - touches.startX;
                const dy = touches.currentY - touches.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
                
                if (distance > 20) {
                    const angle = Math.atan2(dy, dx);
                    
                    if (angle > -Math.PI/8 && angle <= Math.PI/8) {
                        keys['d'] = true;
                    } else if (angle > Math.PI/8 && angle <= 3*Math.PI/8) {
                        keys['d'] = true;
                        keys['s'] = true;
                    } else if (angle > 3*Math.PI/8 && angle <= 5*Math.PI/8) {
                        keys['s'] = true;
                    } else if (angle > 5*Math.PI/8 && angle <= 7*Math.PI/8) {
                        keys['a'] = true;
                        keys['s'] = true;
                    } else if (angle > 7*Math.PI/8 || angle <= -7*Math.PI/8) {
                        keys['a'] = true;
                    } else if (angle > -7*Math.PI/8 && angle <= -5*Math.PI/8) {
                        keys['a'] = true;
                        keys['w'] = true;
                    } else if (angle > -5*Math.PI/8 && angle <= -3*Math.PI/8) {
                        keys['w'] = true;
                    } else if (angle > -3*Math.PI/8 && angle <= -Math.PI/8) {
                        keys['d'] = true;
                        keys['w'] = true;
                    }
                }
            }
        }
        
        // MAIN BUG FIX: Fixed handleTouchEnd function
        function handleTouchEnd(e) {
            e.preventDefault();
            touches.isMoving = false;
            touches.joystickActive = false;
            
            // FIX: Reset joystick knob to center position
            const knob = document.getElementById('joystickKnob');
            if (knob) {
                knob.style.transform = 'translate(-50%, -50%)';
            }
            
            // Clear all movement keys
            if (game.mode === 'exploration') {
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            } else if (game.mode === 'combat') {
                keys['a'] = keys['d'] = keys['j'] = keys['k'] = keys[' '] = false;
            }
        }

        function openSaveMenu() {
            const menu = document.getElementById('saveMenu');
            const slotsDiv = document.getElementById('saveSlots');
            
            slotsDiv.innerHTML = '';
            
            for (let i = 1; i <= 3; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.style.cssText = 'margin: 10px 0; padding: 15px; border: 2px solid #666; background: #111;';
                
                const saveInfo = getSaveInfo(i);
                
                if (saveInfo) {
                    const date = new Date(saveInfo.timestamp);
                    slotDiv.innerHTML = `
                        <h3>Slot ${i} ${i === game.saveSlot ? '(Current)' : ''}</h3>
                        <p>${saveInfo.advancement} - Madra: ${saveInfo.madraCollected} - Wins: ${saveInfo.combatWins}</p>
                        <p>Saved: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}</p>
                        <button onclick="saveToSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Save Here</button>
                        <button onclick="loadFromSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Load</button>
                        <button onclick="deleteSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer; background: #f00;">Delete</button>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <h3>Slot ${i} - Empty</h3>
                        <button onclick="saveToSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Save Here</button>
                    `;
                }
                
                slotsDiv.appendChild(slotDiv);
            }
            
            menu.style.display = 'block';
            game.paused = true;
        }

        function closeSaveMenu() {
            document.getElementById('saveMenu').style.display = 'none';
            game.paused = false;
        }

        function saveToSlot(slot) {
            game.saveSlot = slot;
            saveGame(slot);
            openSaveMenu();
        }

        function loadFromSlot(slot) {
            game.saveSlot = slot;
            if (loadGame(slot)) {
                closeSaveMenu();
            }
        }

        function deleteSlot(slot) {
            if (confirm(`Delete save in slot ${slot}?`)) {
                deleteSave(slot);
                openSaveMenu();
            }
        }

        function generateWorld() {
            game.world.tiles = [];
            game.world.entities = [];
            game.world.npcs = [];
            
            for (let y = 0; y < game.world.height; y += 40) {
                for (let x = 0; x < game.world.width; x += 40) {
                    const tile = {
                        x: x,
                        y: y,
                        type: 'grass'
                    };
                    
                    if (Math.random() < 0.1) tile.type = 'stone';
                    if (Math.random() < 0.05) tile.type = 'flower';
                    
                    game.world.tiles.push(tile);
                }
            }

            for (let x = 0; x < game.world.width; x += 40) {
                game.world.tiles.push({ x: x, y: 0, type: 'wall' });
                game.world.tiles.push({ x: x, y: game.world.height - 40, type: 'wall' });
            }
            for (let y = 0; y < game.world.height; y += 40) {
                game.world.tiles.push({ x: 0, y: y, type: 'wall' });
                game.world.tiles.push({ x: game.world.width - 40, y: y, type: 'wall' });
            }

            for (let i = 0; i < 20; i++) {
                game.world.entities.push({
                    type: 'madra',
                    x: Math.random() * (game.world.width - 100) + 50,
                    y: Math.random() * (game.world.height - 100) + 50,
                    collected: false,
                    pulse: 0
                });
            }

            const enemyTypes = ['student', 'iron', 'jade'];
            for (let i = 0; i < 8; i++) {
                game.world.entities.push({
                    type: 'enemy',
                    enemyType: enemyTypes[Math.floor(Math.random() * enemyTypes.length)],
                    x: Math.random() * (game.world.width - 200) + 100,
                    y: Math.random() * (game.world.height - 200) + 100,
                    health: 100,
                    patrol: {
                        startX: 0,
                        startY: 0,
                        direction: 1
                    }
                });
            }

            game.world.npcs.push({
                name: 'Elder Whisper',
                x: 800,
                y: 600,
                dialogue: [
                    "The path of the Unsouled is difficult, but not impossible.",
                    "Collect madra from the sacred orbs scattered across the valley.",
                    "Prove yourself in combat, and perhaps you'll advance beyond Copper."
                ]
            });

            game.world.entities.forEach(entity => {
                if (entity.type === 'enemy') {
                    entity.patrol.startX = entity.x;
                    entity.patrol.startY = entity.y;
                }
            });
        }

        function updateExploration() {
            if (game.paused) return;
            
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy = -game.player.speed;
            if (keys['s'] || keys['arrowdown']) dy = game.player.speed;
            if (keys['a'] || keys['arrowleft']) dx = -game.player.speed;
            if (keys['d'] || keys['arrowright']) dx = game.player.speed;

            const newX = game.player.x + dx;
            const newY = game.player.y + dy;
            
            let canMove = true;
            game.world.tiles.forEach(tile => {
                if (tile.type === 'wall') {
                    if (newX < tile.x + 40 && newX + 20 > tile.x &&
                        newY < tile.y + 40 && newY + 20 > tile.y) {
                        canMove = false;
                    }
                }
            });

            if (canMove) {
                game.player.x = Math.max(20, Math.min(game.world.width - 40, newX));
                game.player.y = Math.max(20, Math.min(game.world.height - 40, newY));
            }

            game.camera.x = Math.max(0, Math.min(game.world.width - canvas.width, 
                game.player.x - canvas.width / 2));
            game.camera.y = Math.max(0, Math.min(game.world.height - canvas.height, 
                game.player.y - canvas.height / 2));

            game.world.entities.forEach(entity => {
                const dist = Math.hypot(entity.x - game.player.x, entity.y - game.player.y);
                
                if (entity.type === 'madra' && !entity.collected && dist < 30) {
                    entity.collected = true;
                    game.player.madraCollected += 10;
                    game.player.madra = Math.min(game.player.maxMadra, game.player.madra + 20);
                    createFloatingText('+10 Madra', entity.x - game.camera.x, entity.y - game.camera.y);
                    checkAdvancement();
                }
                
                if (entity.type === 'enemy' && dist < 40) {
                    startCombat(entity);
                }

                if (entity.type === 'madra' && !entity.collected) {
                    entity.pulse += 0.1;
                }
                
                if (entity.type === 'enemy') {
                    entity.x += entity.patrol.direction * 0.5;
                    if (Math.abs(entity.x - entity.patrol.startX) > 100) {
                        entity.patrol.direction *= -1;
                    }
                }
            });

            if (keys[' '] && (!game.dialogue || !game.dialogue.active)) {
                game.world.npcs.forEach(npc => {
                    const dist = Math.hypot(npc.x - game.player.x, npc.y - game.player.y);
                    if (dist < 50) {
                        if (npc.dialogue && npc.dialogue.length > 0) {
                            const dialogueIndex = Math.floor(Math.random() * npc.dialogue.length);
                            showDialogue(npc.dialogue[dialogueIndex], npc.name);
                        }
                    }
                });
            }
            
            if ((keys[' '] || keys['escape']) && game.dialogue && game.dialogue.active && !game.dialogue.choices) {
                hideDialogue();
                keys[' '] = false;
            }
        }

        function startCombat(enemy) {
            game.mode = 'combat';
            game.combat.enemyType = enemy.enemyType;
            game.combat.enemyHealth = game.combat.enemyMaxHealth = enemy.health;
            game.combat.playerX = 200;
            game.combat.enemyX = 600;
            game.combat.playerY = game.combat.enemyY = 400;
            game.combat.playerState = game.combat.enemyState = 'idle';
            game.combat.combo = 0;
            
            document.getElementById('explorationInstructions').style.display = 'none';
            document.getElementById('combatInstructions').style.display = 'block';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('combatUI').style.display = 'block';
            document.getElementById('enemyName').textContent = enemy.enemyType.toUpperCase();
            
            if (isMobile) {
                document.getElementById('explorationControls').style.display = 'none';
                document.getElementById('combatControls').style.display = 'block';
            }
            
            flashScreen();
            
            const index = game.world.entities.indexOf(enemy);
            if (index > -1) {
                game.world.entities.splice(index, 1);
            }
        }

        function updateCombat() {
            if (keys['a']) {
                game.combat.playerX = Math.max(50, game.combat.playerX - 5);
                game.combat.playerFacing = -1;
            }
            if (keys['d']) {
                game.combat.playerX = Math.min(400, game.combat.playerX + 5);
                game.combat.playerFacing = 1;
            }
            
            if (keys['j'] && game.combat.playerState === 'idle') {
                performAttack('punch', 10, 0);
            }
            if (keys['k'] && game.combat.playerState === 'idle') {
                performAttack('kick', 15, 0);
            }
            if (keys[' '] && game.combat.playerState === 'idle' && game.player.madra >= 30) {
                performAttack('emptyPalm', 0, 30);
            }
            
            game.combat.blockActive = keys['l'];

            if (game.combat.playerState === 'attacking') {
                setTimeout(() => {
                    game.combat.playerState = 'idle';
                }, 300);
            }

            const distance = Math.abs(game.combat.enemyX - game.combat.playerX);
            
            if (game.combat.enemyStunnedUntil && Date.now() < game.combat.enemyStunnedUntil) {
                game.combat.enemyState = 'stunned';
            } else if (game.combat.enemyState === 'stunned') {
                game.combat.enemyState = 'idle';
                game.combat.enemyStunnedUntil = null;
            }
            
            if (game.combat.enemyState === 'idle') {
                if (distance > 100) {
                    game.combat.enemyX += game.combat.enemyX > game.combat.playerX ? -3 : 3;
                } else if (Math.random() < 0.02) {
                    game.combat.enemyState = 'attacking';
                    setTimeout(() => {
                        if (distance < 100 && !game.combat.blockActive && game.combat.enemyState !== 'stunned') {
                            game.player.health = Math.max(0, game.player.health - 10);
                            game.combat.combo = 0;
                            screenShake();
                        }
                        if (game.combat.enemyState !== 'stunned') {
                            game.combat.enemyState = 'idle';
                        }
                    }, 400);
                }
            }

            if (game.combat.enemyHealth <= 0) {
                endCombat(true);
            } else if (game.player.health <= 0) {
                endCombat(false);
            }

            document.getElementById('combatPlayerHealth').style.width = 
                (game.player.health / game.player.maxHealth * 100) + '%';
            document.getElementById('combatPlayerMadra').style.width = 
                (game.player.madra / game.player.maxMadra * 100) + '%';
            document.getElementById('combatEnemyHealth').style.width = 
                (game.combat.enemyHealth / game.combat.enemyMaxHealth * 100) + '%';
        }

        function performAttack(type, damage, madraCost) {
            game.combat.playerState = 'attacking';
            
            const distance = Math.abs(game.combat.enemyX - game.combat.playerX);
            
            if (type === 'emptyPalm') {
                if (game.player.madra >= 30) {
                    game.player.madra -= 30;
                    
                    let stunDuration = 500;
                    if (game.player.advancement === 'Copper') stunDuration = 1000;
                    if (game.player.advancement === 'Iron') stunDuration = 1500;
                    if (game.player.advancement === 'Jade') stunDuration = 2000;
                    if (game.player.advancement === 'Gold') stunDuration = 2500;
                    
                    game.combat.enemyState = 'stunned';
                    game.combat.enemyStunnedUntil = Date.now() + stunDuration;
                    
                    flashScreen();
                    createFloatingText('DISRUPTED!', game.combat.enemyX, game.combat.enemyY - 50);
                    
                    if (game.combat.enemyState === 'attacking') {
                        game.combat.enemyState = 'stunned';
                    }
                    
                    if (game.combat.enemyMadra !== undefined) {
                        game.combat.enemyMadra = Math.max(0, game.combat.enemyMadra - 20);
                    }
                    
                    game.combat.emptyPalmWindow = true;
                    setTimeout(() => {
                        game.combat.emptyPalmWindow = false;
                    }, stunDuration);
                }
            } else if (distance < 100) {
                let finalDamage = damage;
                if (game.combat.emptyPalmWindow) {
                    finalDamage = Math.floor(damage * 1.5);
                    createFloatingText('CRITICAL!', game.combat.enemyX, game.combat.enemyY - 80);
                }
                
                game.combat.enemyHealth = Math.max(0, game.combat.enemyHealth - finalDamage);
                game.combat.combo++;
                game.combat.lastHit = Date.now();
                
                if (game.combat.combo > 1) {
                    document.getElementById('comboCount').textContent = game.combat.combo;
                    document.getElementById('comboCounter').style.display = 'block';
                }
                
                screenShake();
                createFloatingText(finalDamage + ' DMG', game.combat.enemyX, game.combat.enemyY - 50);
            }
        }

        function endCombat(victory) {
            game.mode = 'exploration';
            document.getElementById('explorationInstructions').style.display = 'block';
            document.getElementById('combatInstructions').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('combatUI').style.display = 'none';
            document.getElementById('comboCounter').style.display = 'none';
            
            if (isMobile) {
                document.getElementById('explorationControls').style.display = 'block';
                document.getElementById('combatControls').style.display = 'none';
            }
            
            if (victory) {
                game.player.combatWins++;
                game.player.madraCollected += 50;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + 20);
                showDialogue("Victory! You've gained strength from combat.");
                checkAdvancement();
                saveGame();
            } else {
                game.player.health = game.player.maxHealth;
                game.player.x = 400;
                game.player.y = 300;
                showDialogue("Defeated... but you rise again, determined.");
            }
            
            updateUI();
        }

        function checkAdvancement() {
            const advancements = [
                { name: 'Copper', madra: 100, wins: 2 },
                { name: 'Iron', madra: 300, wins: 5 },
                { name: 'Jade', madra: 600, wins: 10 },
                { name: 'Gold', madra: 1000, wins: 20 }
            ];
            
            advancements.forEach(level => {
                if (game.player.advancement !== level.name && 
                    game.player.madraCollected >= level.madra && 
                    game.player.combatWins >= level.wins) {
                    game.player.advancement = level.name;
                    game.player.maxHealth += 50;
                    game.player.maxMadra += 50;
                    game.player.health = game.player.maxHealth;
                    game.player.madra = game.player.maxMadra;
                    game.player.speed += 1;
                    
                    showAdvancement(level.name);
                }
            });
        }

        function showAdvancement(level) {
            const notice = document.getElementById('advancementNotice');
            notice.innerHTML = `ADVANCEMENT!<br>You have reached ${level}!`;
            notice.style.display = 'block';
            flashScreen();
            
            setTimeout(() => {
                notice.style.display = 'none';
            }, 3000);
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (game.mode === 'exploration') {
                renderExploration();
            } else {
                renderCombat();
            }
        }

        function renderExploration() {
            game.world.tiles.forEach(tile => {
                const screenX = tile.x - game.camera.x;
                const screenY = tile.y - game.camera.y;
                
                if (screenX > -40 && screenX < canvas.width && 
                    screenY > -40 && screenY < canvas.height) {
                    
                    ctx.fillStyle = tile.type === 'grass' ? '#2d5016' : 
                                   tile.type === 'stone' ? '#444' :
                                   tile.type === 'flower' ? '#2d5016' : '#222';
                    ctx.fillRect(screenX, screenY, 40, 40);
                    
                    if (tile.type === 'flower') {
                        ctx.fillStyle = '#ff69b4';
                        ctx.fillRect(screenX + 15, screenY + 15, 10, 10);
                    }
                }
            });

            game.world.entities.forEach(entity => {
                const screenX = entity.x - game.camera.x;
                const screenY = entity.y - game.camera.y;
                
                if (entity.type === 'madra' && !entity.collected) {
                    const pulse = Math.sin(entity.pulse) * 5;
                    ctx.fillStyle = '#00ccff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ccff';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 15 + pulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                if (entity.type === 'enemy') {
                    ctx.fillStyle = entity.enemyType === 'student' ? '#654321' :
                                   entity.enemyType === 'iron' ? '#888' : '#0f0';
                    ctx.fillRect(screenX - 15, screenY - 30, 30, 40);
                    
                    ctx.fillStyle = '#fdbcb4';
                    ctx.fillRect(screenX - 10, screenY - 40, 20, 20);
                }
            });

            game.world.npcs.forEach(npc => {
                const screenX = npc.x - game.camera.x;
                const screenY = npc.y - game.camera.y;
                
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(screenX - 20, screenY - 40, 40, 50);
                
                ctx.fillStyle = '#fdbcb4';
                ctx.fillRect(screenX - 15, screenY - 55, 30, 25);
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(npc.name, screenX, screenY - 65);
            });

            const playerScreenX = game.player.x - game.camera.x;
            const playerScreenY = game.player.y - game.camera.y;
            
            ctx.fillStyle = game.player.advancement === 'Unsouled' ? '#333' :
                           game.player.advancement === 'Copper' ? '#b87333' :
                           game.player.advancement === 'Iron' ? '#888' :
                           game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
            ctx.fillRect(playerScreenX - 10, playerScreenY - 20, 20, 30);
            
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(playerScreenX - 8, playerScreenY - 30, 16, 16);
            
            if (game.player.advancement !== 'Unsouled') {
                ctx.strokeStyle = game.player.advancement === 'Copper' ? '#b87333' :
                                 game.player.advancement === 'Iron' ? '#888' :
                                 game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(playerScreenX - 15, playerScreenY - 35, 30, 40);
            }
        }

        function renderCombat() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 450, canvas.width, 150);
            
            ctx.save();
            ctx.translate(game.combat.playerX, game.combat.playerY);
            ctx.scale(game.combat.playerFacing, 1);
            
            ctx.fillStyle = game.player.advancement === 'Unsouled' ? '#333' :
                           game.player.advancement === 'Copper' ? '#b87333' :
                           game.player.advancement === 'Iron' ? '#888' :
                           game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
            ctx.fillRect(-20, -60, 40, 60);
            
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-15, -75, 30, 25);
            
            if (game.combat.playerState === 'attacking') {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(20, -40, 30, 10);
            }
            
            if (game.combat.blockActive) {
                ctx.strokeStyle = '#00f';
                ctx.lineWidth = 3;
                ctx.strokeRect(-30, -80, 60, 80);
            }
            
            ctx.restore();
            
            ctx.save();
            ctx.translate(game.combat.enemyX, game.combat.enemyY);
            
            ctx.fillStyle = game.combat.enemyType === 'student' ? '#654321' :
                           game.combat.enemyType === 'iron' ? '#888' : '#0f0';
            ctx.fillRect(-20, -60, 40, 60);
            
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-15, -75, 30, 25);
            
            if (game.combat.enemyState === 'stunned') {
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
                ctx.strokeRect(-25, -80, 50, 80);
                ctx.globalAlpha = 1;
                
                for (let i = 0; i < 3; i++) {
                    const angle = (Date.now() * 0.01 + i * 2) % (Math.PI * 2);
                    const x = Math.cos(angle) * 30;
                    const y = Math.sin(angle) * 30 - 40;
                    ctx.fillStyle = '#00ccff';
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                }
            }
            
            if (game.combat.enemyState === 'attacking') {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(-50, -40, 30, 10);
            }
            
            ctx.restore();
        }

        function updateUI() {
            document.getElementById('advancement').textContent = game.player.advancement;
            document.getElementById('playerHealth').style.width = 
                (game.player.health / game.player.maxHealth * 100) + '%';
            document.getElementById('playerMadra').style.width = 
                (game.player.madra / game.player.maxMadra * 100) + '%';
            document.getElementById('madraCount').textContent = game.player.madraCollected;
            document.getElementById('winCount').textContent = game.player.combatWins;
        }

        function showDialogue(text, speaker = '') {
            if (!game.dialogue) {
                game.dialogue = {
                    active: false,
                    speaker: '',
                    text: '',
                    queue: [],
                    choices: null
                };
            }
            
            game.dialogue.active = true;
            game.dialogue.text = text;
            game.dialogue.speaker = speaker;
            game.paused = true;
            
            const dialogueDiv = document.getElementById('dialogue');
            if (dialogueDiv) {
                dialogueDiv.innerHTML = speaker ? `<strong>${speaker}:</strong> ${text}` : text;
                dialogueDiv.style.display = 'block';
            }
        }
        
        function hideDialogue() {
            if (game.dialogue) {
                game.dialogue.active = false;
            }
            game.paused = false;
            const dialogueDiv = document.getElementById('dialogue');
            if (dialogueDiv) {
                dialogueDiv.style.display = 'none';
            }
        }

        function createFloatingText(text, x, y) {
            const div = document.createElement('div');
            div.className = 'floatingText';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.getElementById('gameContainer').appendChild(div);
            
            setTimeout(() => {
                div.remove();
            }, 1000);
        }

        function flashScreen() {
            const flash = document.getElementById('screenFlash');
            flash.style.opacity = '0.8';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 100);
        }

        let shakeAmount = 0;
        function screenShake() {
            shakeAmount = 10;
        }

        function toggleFullscreen() {
            const container = document.getElementById('gameContainer');
            
            if (!document.fullscreenElement) {
                const requestFullscreen = container.requestFullscreen || 
                                        container.mozRequestFullScreen || 
                                        container.webkitRequestFullscreen || 
                                        container.msRequestFullscreen;
                
                if (requestFullscreen) {
                    requestFullscreen.call(container).then(() => {
                        document.getElementById('fullscreenBtn').textContent = '‚õ∂ Exit Fullscreen';
                        resizeCanvas();
                    }).catch(err => {
                        console.log('Fullscreen not available');
                        const btn = document.getElementById('fullscreenBtn');
                        if (btn) btn.style.display = 'none';
                    });
                }
            } else {
                const exitFullscreen = document.exitFullscreen || 
                                     document.mozCancelFullScreen || 
                                     document.webkitExitFullscreen || 
                                     document.msExitFullscreen;
                
                if (exitFullscreen) {
                    exitFullscreen.call(document).then(() => {
                        document.getElementById('fullscreenBtn').textContent = '‚õ∂ Fullscreen';
                        resizeCanvas();
                    });
                }
            }
        }
        
        document.addEventListener('fullscreenchange', resizeCanvas);
        window.toggleFullscreen = toggleFullscreen;
        
        function initializeMobileControls() {
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                touches.joystickActive = true;
                touches.startX = rect.left + rect.width / 2;
                touches.startY = rect.top + rect.height / 2;
                updateJoystick(touch.clientX, touch.clientY);
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (touches.joystickActive) {
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                }
            });
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                touches.joystickActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            });
            
            document.getElementById('actionA').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            
            document.getElementById('actionA').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
            
            document.getElementById('combatMoveLeft').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['a'] = true;
            });
            
            document.getElementById('combatMoveLeft').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['a'] = false;
            });
            
            document.getElementById('combatMoveRight').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['d'] = true;
            });
            
            document.getElementById('combatMoveRight').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['d'] = false;
            });
            
            document.getElementById('actionB').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['j'] = true;
            });
            
            document.getElementById('actionB').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['j'] = false;
            });
            
            document.getElementById('actionSpecial').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            
            document.getElementById('actionSpecial').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
        }
        
        function updateJoystick(touchX, touchY) {
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            const rect = joystick.getBoundingClientRect();
            
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = touchX - centerX;
            const dy = touchY - centerY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = rect.width / 2 - 20;
            
            let knobX = dx;
            let knobY = dy;
            
            if (distance > maxDistance) {
                knobX = (dx / distance) * maxDistance;
                knobY = (dy / distance) * maxDistance;
            }
            
            knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
            
            keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            
            if (distance > 20) {
                const angle = Math.atan2(dy, dx);
                
                if (angle > -Math.PI/4 && angle <= Math.PI/4) {
                    keys['d'] = true;
                } else if (angle > Math.PI/4 && angle <= 3*Math.PI/4) {
                    keys['s'] = true;
                } else if (angle > 3*Math.PI/4 || angle <= -3*Math.PI/4) {
                    keys['a'] = true;
                } else {
                    keys['w'] = true;
                }
            }
        }
        
        function gameLoop() {
            if (!game.paused) {
                if (game.mode === 'exploration') {
                    updateExploration();
                    autoSave();
                } else if (game.mode === 'combat') {
                    updateCombat();
                }
                
                updateUI();
                
                if (shakeAmount > 0) {
                    const shakeX = (Math.random() - 0.5) * shakeAmount;
                    const shakeY = (Math.random() - 0.5) * shakeAmount;
                    const currentTransform = canvas.style.transform;
                    canvas.style.transform = currentTransform + ` translate(${shakeX}px, ${shakeY}px)`;
                    shakeAmount *= 0.9;
                } else {
                    canvas.style.transform = 'translate(-50%, -50%)';
                }
                
                if (Date.now() - game.combat.lastHit > 2000) {
                    game.combat.combo = 0;
                    document.getElementById('comboCounter').style.display = 'none';
                }
                
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        testSaveMethod();
        generateWorld();
        
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('instructions').style.display = 'none';
            initializeMobileControls();
        }
        
        let helpShown = false;
        window.showQuickHelp = function() {
            if (!helpShown) {
                const quickHelp = document.getElementById('quickHelp');
                if (quickHelp) {
                    quickHelp.style.display = 'block';
                    setTimeout(() => {
                        quickHelp.style.display = 'none';
                    }, 5000);
                    helpShown = true;
                }
            }
        };
        
        if (saveMethod !== 'none' && getSaveInfo(1)) {
            const shouldLoad = confirm("Save file found! Load your progress?");
            if (shouldLoad) {
                loadGame(1);
            }
        }
        
        game.lastSaveTime = Date.now();
        gameLoop();
        
        setTimeout(() => {
            if (saveMethod === 'memory') {
                showDialogue("Note: Browser storage blocked. Saves are temporary - download to keep them!");
            } else {
                showDialogue("Welcome to Sacred Valley. Prove yourself worthy of advancement!");
            }
            
            window.showQuickHelp();
        }, 1000);

        // Make save functions global
        window.saveToSlot = saveToSlot;
        window.loadFromSlot = loadFromSlot;
        window.deleteSlot = deleteSlot;
        window.closeSaveMenu = closeSaveMenu;
    </script>
</body>
</html>
