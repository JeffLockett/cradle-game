<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cradle Adventure: Path of Sacred Valley</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            border: 3px solid #333;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            width: 100%;
            height: 100vh;
            max-width: 100%;
            max-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            font-size: 14px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .healthBar {
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid #fff;
            margin: 5px 0;
            position: relative;
        }

        .healthFill {
            height: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }

        .madraBar {
            width: 200px;
            height: 15px;
            background-color: #222;
            border: 2px solid #66f;
            margin: 5px 0;
            position: relative;
        }

        .madraFill {
            height: 100%;
            background: linear-gradient(90deg, #0066ff, #00ccff);
            transition: width 0.3s;
        }

        #combatUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: white;
            display: none;
            pointer-events: none;
        }

        .combatBars {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .fighterInfo {
            text-align: center;
        }

        .comboCounter {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #ff0;
            text-shadow: 3px 3px 0px #f00;
            display: none;
        }

        #dialogue {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ff88;
            border-radius: 10px;
            padding: 15px 25px;
            color: white;
            max-width: 80%;
            display: none;
            text-align: center;
            font-size: 16px;
            z-index: 500;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .floatingText {
            position: absolute;
            color: #ff0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0px black;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            to {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        .screenFlash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            opacity: 0;
            pointer-events: none;
        }

        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            top: 0;
            pointer-events: none;
            display: none;
        }
        
        .touch-zone {
            position: absolute;
            pointer-events: auto;
            opacity: 0.3;
            transition: opacity 0.2s;
        }
        
        .touch-zone:active {
            opacity: 0.6;
        }
        
        #virtualJoystick {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
        }
        
        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
            pointer-events: none;
        }
        
        .action-button {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 1px 1px 0 black;
        }
        
        #actionA {
            bottom: 100px;
            right: 140px;
        }
        
        #actionB {
            bottom: 50px;
            right: 80px;
        }
        
        #actionSpecial {
            bottom: 150px;
            right: 80px;
            background: rgba(0, 100, 255, 0.3);
        }
        
        #combatMoveLeft {
            bottom: 50px;
            left: 50px;
            width: 80px;
            height: 80px;
        }
        
        #combatMoveRight {
            bottom: 50px;
            left: 150px;
            width: 80px;
            height: 80px;
        }
        
        .mobile-instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            text-shadow: 2px 2px 0 black;
            pointer-events: none;
        }

        #advancementNotice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0;
            font-size: 36px;
            text-shadow: 3px 3px 0px #f00;
            display: none;
            text-align: center;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <button id="fullscreenBtn" onclick="toggleFullscreen()">⛶ Fullscreen</button>
        
        <div id="ui">
            <div>Wei Shi Lindon - <span id="advancement">Unsouled</span></div>
            <div class="healthBar">
                <div class="healthFill" id="playerHealth" style="width: 100%"></div>
            </div>
            <div class="madraBar">
                <div class="madraFill" id="playerMadra" style="width: 100%"></div>
            </div>
            <div>Madra Collected: <span id="madraCount">0</span></div>
            <div>Combat Wins: <span id="winCount">0</span></div>
        </div>

        <div id="combatUI">
            <div class="combatBars">
                <div class="fighterInfo">
                    <h3>LINDON</h3>
                    <div class="healthBar" style="width: 300px">
                        <div class="healthFill" id="combatPlayerHealth" style="width: 100%"></div>
                    </div>
                    <div class="madraBar" style="width: 300px">
                        <div class="madraFill" id="combatPlayerMadra" style="width: 100%"></div>
                    </div>
                </div>
                <div class="fighterInfo">
                    <h3 id="enemyName">ENEMY</h3>
                    <div class="healthBar" style="width: 300px">
                        <div class="healthFill" id="combatEnemyHealth" style="width: 100%; background-color: #f00"></div>
                    </div>
                </div>
            </div>
            <div class="comboCounter" id="comboCounter">COMBO x<span id="comboCount">0</span></div>
        </div>

        <div id="dialogue"></div>
        <div class="screenFlash" id="screenFlash"></div>
        <div id="advancementNotice"></div>

        <div id="instructions">
            <div id="explorationInstructions">
                <div class="control-line">
                    <span>Move:</span>
                    <span class="key">WASD/Arrows</span>
                </div>
                <div class="control-line">
                    <span>Interact:</span>
                    <span class="key">SPACE</span>
                </div>
                <div class="control-line">
                    <span>Save:</span>
                    <span class="key">F5</span>
                </div>
                <div class="control-line">
                    <span>Load:</span>
                    <span class="key">F9</span>
                </div>
                <div class="control-line">
                    <span>Save Menu:</span>
                    <span class="key">M</span>
                </div>
                <div class="help-reminder">Press ? for Full Help</div>
            </div>
            <div id="combatInstructions" style="display: none">
                <div class="control-line">
                    <span>Move:</span>
                    <span class="key">A/D</span>
                </div>
                <div class="control-line">
                    <span>Punch:</span>
                    <span class="key">J</span>
                </div>
                <div class="control-line">
                    <span>Kick:</span>
                    <span class="key">K</span>
                </div>
                <div class="control-line">
                    <span>Block:</span>
                    <span class="key">L (Hold)</span>
                </div>
                <div class="control-line">
                    <span>Empty Palm:</span>
                    <span class="key">SPACE</span>
                </div>
                <div class="help-reminder">Press ? for Full Help</div>
            </div>
        </div>
        
        <button id="controlsToggle" onclick="toggleControls()">Controls (C)</button>
        
        <div class="controls-hint" id="controlsHint">
            Press C for Controls
        </div>
        
        <!-- Full Controls Overlay -->
        <div id="fullControls">
            <span class="close-controls" onclick="hideControls()">×</span>
            <h2>Sacred Artist Control Manual</h2>
            
            <div class="control-section">
                <h3>🎮 Basic Movement</h3>
                <div class="control-item">
                    <span>Move</span>
                    <span class="control-key">WASD / Arrow Keys</span>
                </div>
                <div class="control-item">
                    <span>Interact/Talk</span>
                    <span class="control-key">SPACE</span>
                </div>
                <div class="control-item">
                    <span>Run (with certain paths)</span>
                    <span class="control-key">SHIFT</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>⚔️ Combat Controls</h3>
                <div class="control-item">
                    <span>Move Left/Right</span>
                    <span class="control-key">A / D</span>
                </div>
                <div class="control-item">
                    <span>Punch</span>
                    <span class="control-key">J</span>
                </div>
                <div class="control-item">
                    <span>Kick</span>
                    <span class="control-key">K</span>
                </div>
                <div class="control-item">
                    <span>Block</span>
                    <span class="control-key">L (Hold)</span>
                </div>
                <div class="control-item">
                    <span>Empty Palm (Uses Madra)</span>
                    <span class="control-key">SPACE</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>💾 System Controls</h3>
                <div class="control-item">
                    <span>Quick Save</span>
                    <span class="control-key">F5</span>
                </div>
                <div class="control-item">
                    <span>Quick Load</span>
                    <span class="control-key">F9</span>
                </div>
                <div class="control-item">
                    <span>Save Menu</span>
                    <span class="control-key">M</span>
                </div>
                <div class="control-item">
                    <span>Toggle Controls</span>
                    <span class="control-key">C</span>
                </div>
                <div class="control-item">
                    <span>Close Menus</span>
                    <span class="control-key">ESC</span>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px; color: #00ff88;">
                <em>"The dragon advances through understanding."</em>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls">
            <!-- Exploration Controls -->
            <div id="explorationControls">
                <div id="virtualJoystick" class="touch-zone">
                    <div id="joystickKnob"></div>
                </div>
                <div id="actionA" class="action-button touch-zone">Talk</div>
                <div class="mobile-instructions">Move: Left side | Interact: Right side</div>
            </div>
            
            <!-- Combat Controls -->
            <div id="combatControls" style="display: none;">
                <div id="combatMoveLeft" class="action-button touch-zone">←</div>
                <div id="combatMoveRight" class="action-button touch-zone">→</div>
                <div id="actionB" class="action-button touch-zone">Punch</div>
                <div id="actionA" class="action-button touch-zone">Kick</div>
                <div id="actionSpecial" class="action-button touch-zone">Palm</div>
                <div class="mobile-instructions">Tap buttons to fight!</div>
            </div>
        </div>
        
        <!-- Save Menu -->
        <div id="saveMenu" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 3px solid #fff; padding: 20px; color: white; text-align: center; z-index: 100;">
            <h2 style="margin-top: 0;">SAVE MENU</h2>
            <div id="saveSlots" style="margin: 20px 0;"></div>
            <div style="margin-top: 20px;">
                <button onclick="closeSaveMenu()" style="padding: 10px 20px; font-size: 16px; cursor: pointer;">Close (ESC)</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // Responsive canvas sizing
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // Maintain 4:3 aspect ratio (classic game ratio)
            const aspectRatio = 4 / 3;
            let newWidth, newHeight;
            
            if (containerWidth / containerHeight > aspectRatio) {
                // Container is wider than aspect ratio
                newHeight = containerHeight;
                newWidth = newHeight * aspectRatio;
            } else {
                // Container is taller than aspect ratio
                newWidth = containerWidth;
                newHeight = newWidth / aspectRatio;
            }
            
            // Set canvas internal resolution (game resolution)
            canvas.width = 800;  // Internal game width
            canvas.height = 600; // Internal game height
            
            // Set canvas display size
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
            
            // Center the canvas
            canvas.style.position = 'absolute';
            canvas.style.left = '50%';
            canvas.style.top = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
        }
        
        // Call resize on load and window resize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game State
        const game = {
            mode: 'exploration', // 'exploration' or 'combat'
            player: {
                x: 400,
                y: 300,
                health: 100,
                maxHealth: 100,
                madra: 100,
                maxMadra: 100,
                madraCollected: 0,
                advancement: 'Unsouled',
                speed: 3,
                combatWins: 0,
                techniques: ['punch', 'kick', 'emptyPalm']
            },
            camera: {
                x: 0,
                y: 0
            },
            combat: {
                playerX: 200,
                playerY: 400,
                playerVelY: 0,
                playerState: 'idle',
                playerFacing: 1,
                enemyX: 600,
                enemyY: 400,
                enemyHealth: 100,
                enemyMaxHealth: 100,
                enemyState: 'idle',
                enemyType: null,
                combo: 0,
                lastHit: 0,
                blockActive: false
            },
            world: {
                width: 1600,
                height: 1200,
                tiles: [],
                entities: [],
                npcs: []
            },
            saveSlot: 1,
            lastSaveTime: 0
        };

        // Save System Functions
        let saveMethod = 'none';
        
        // Test which save method works
        function testSaveMethod() {
            // Try localStorage first
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                saveMethod = 'localStorage';
                console.log('Using localStorage for saves');
            } catch (e) {
                // Fall back to memory saves
                saveMethod = 'memory';
                console.log('Using memory saves (temporary)');
            }
        }
        
        // In-memory save storage (backup)
        const memorySaves = {};
        
        function saveGame(slot = game.saveSlot) {
            const saveData = {
                player: {
                    x: game.player.x,
                    y: game.player.y,
                    health: game.player.health,
                    maxHealth: game.player.maxHealth,
                    madra: game.player.madra,
                    maxMadra: game.player.maxMadra,
                    madraCollected: game.player.madraCollected,
                    advancement: game.player.advancement,
                    speed: game.player.speed,
                    combatWins: game.player.combatWins,
                    techniques: [...game.player.techniques]
                },
                world: {
                    entities: game.world.entities.map(e => ({
                        type: e.type,
                        x: e.x,
                        y: e.y,
                        collected: e.collected,
                        enemyType: e.enemyType,
                        health: e.health
                    }))
                },
                timestamp: Date.now(),
                playTime: Date.now() - game.lastSaveTime
            };
            
            try {
                if (saveMethod === 'localStorage') {
                    localStorage.setItem(`cradleSave_${slot}`, JSON.stringify(saveData));
                } else {
                    // Use memory saves
                    memorySaves[`cradleSave_${slot}`] = JSON.stringify(saveData);
                }
                
                showSaveNotification('Game Saved!');
                game.lastSaveTime = Date.now();
                
                // Also offer to download save
                if (saveMethod === 'memory') {
                    offerDownloadSave(saveData, slot);
                }
                
                return true;
            } catch (e) {
                console.error('Save error:', e);
                showSaveNotification('Save Failed! Check browser settings.', true);
                return false;
            }
        }
        
        function offerDownloadSave(saveData, slot) {
            // Create download link for save file
            const dataStr = JSON.stringify(saveData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `cradle_save_slot_${slot}.json`;
            
            // Show download prompt
            const downloadPrompt = document.createElement('div');
            downloadPrompt.style.cssText = `
                position: absolute;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: #000;
                border: 2px solid #0f0;
                padding: 10px;
                color: #0f0;
                text-align: center;
                z-index: 1000;
            `;
            downloadPrompt.innerHTML = `
                <p>Browser storage unavailable!</p>
                <button onclick="this.parentElement.querySelector('a').click()" style="padding: 5px 10px; cursor: pointer;">Download Save File</button>
                <button onclick="this.parentElement.remove()" style="padding: 5px 10px; margin-left: 10px; cursor: pointer;">Cancel</button>
            `;
            downloadPrompt.appendChild(link);
            document.getElementById('gameContainer').appendChild(downloadPrompt);
            
            setTimeout(() => downloadPrompt.remove(), 10000);
        }

        function loadGame(slot = 1) {
            try {
                let saveData;
                
                if (saveMethod === 'localStorage') {
                    saveData = localStorage.getItem(`cradleSave_${slot}`);
                } else {
                    saveData = memorySaves[`cradleSave_${slot}`];
                }
                
                if (!saveData) return false;
                
                const data = JSON.parse(saveData);
                
                // Load player data
                Object.assign(game.player, data.player);
                
                // Regenerate world then apply saved state
                generateWorld();
                
                // Apply saved entity states
                if (data.world && data.world.entities) {
                    // Remove entities that were collected/defeated
                    game.world.entities = game.world.entities.filter(entity => {
                        const savedEntity = data.world.entities.find(e => 
                            e.type === entity.type && 
                            Math.abs(e.x - entity.x) < 50 && 
                            Math.abs(e.y - entity.y) < 50
                        );
                        
                        if (savedEntity) {
                            if (savedEntity.type === 'madra' && savedEntity.collected) {
                                return false; // Remove collected madra
                            }
                            if (savedEntity.type === 'enemy' && !savedEntity.health) {
                                return false; // Remove defeated enemies
                            }
                            // Update enemy health
                            if (savedEntity.type === 'enemy') {
                                entity.health = savedEntity.health;
                            }
                        }
                        return true;
                    });
                }
                
                game.lastSaveTime = Date.now();
                updateUI();
                showSaveNotification('Game Loaded!');
                return true;
            } catch (e) {
                console.error('Load error:', e);
                showSaveNotification('Load Failed!', true);
                return false;
            }
        }

        function getSaveInfo(slot) {
            try {
                let saveData;
                
                if (saveMethod === 'localStorage') {
                    saveData = localStorage.getItem(`cradleSave_${slot}`);
                } else {
                    saveData = memorySaves[`cradleSave_${slot}`];
                }
                
                if (!saveData) return null;
                
                const data = JSON.parse(saveData);
                return {
                    advancement: data.player.advancement,
                    madraCollected: data.player.madraCollected,
                    combatWins: data.player.combatWins,
                    timestamp: data.timestamp,
                    playTime: data.playTime
                };
            } catch (e) {
                return null;
            }
        }

        function deleteSave(slot) {
            try {
                if (saveMethod === 'localStorage') {
                    localStorage.removeItem(`cradleSave_${slot}`);
                } else {
                    delete memorySaves[`cradleSave_${slot}`];
                }
                showSaveNotification('Save Deleted!');
                return true;
            } catch (e) {
                return false;
            }
        }

        function showSaveNotification(text, isError = false) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${isError ? '#ff0000' : '#00ff00'};
                color: black;
                padding: 10px 20px;
                font-size: 20px;
                font-weight: bold;
                border: 2px solid white;
                z-index: 1000;
            `;
            notification.textContent = text;
            document.getElementById('gameContainer').appendChild(notification);
            
            setTimeout(() => notification.remove(), 1500);
        }

        // Auto-save functionality
        function autoSave() {
            if (game.mode === 'exploration' && Date.now() - game.lastSaveTime > 30000) {
                saveGame();
            }
        }

        // Input handling
        const keys = {};
        const touches = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            isMoving: false,
            joystickActive: false
        };
        
        // Detect if mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Keyboard events
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Save/Load hotkeys
            if (e.key === 'F5') {
                e.preventDefault();
                saveGame();
            }
            if (e.key === 'F9') {
                e.preventDefault();
                loadGame(game.saveSlot);
            }
            if (e.key.toLowerCase() === 'm' && game.mode === 'exploration') {
                e.preventDefault();
                openSaveMenu();
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                closeSaveMenu();
                hideControls();
            }
            if (e.key.toLowerCase() === 'c') {
                e.preventDefault();
                toggleControls();
            }
            
            // Prevent default for game keys
            if (['w', 'a', 's', 'd', 'j', 'k', 'l', ' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            e.preventDefault();
        });
        
        // Controls overlay functions
        function toggleControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv && controlsDiv.style.display === 'block') {
                hideControls();
            } else {
                showControls();
            }
        }
        
        function showControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv) {
                controlsDiv.style.display = 'block';
                game.paused = true;
                // Hide hint when controls are shown
                const hint = document.getElementById('controlsHint');
                if (hint) hint.style.display = 'none';
            }
        }
        
        function hideControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv) {
                controlsDiv.style.display = 'none';
                game.paused = false;
            }
        }
        
        // Make functions global
        window.toggleControls = toggleControls;
        window.showControls = showControls;
        window.hideControls = hideControls;
        
        // Hide controls hint after first interaction
        let firstInteraction = true;
        window.addEventListener('keydown', () => {
            if (firstInteraction) {
                firstInteraction = false;
                setTimeout(() => {
                    const hint = document.getElementById('controlsHint');
                    if (hint) hint.style.display = 'none';
                }, 5000);
            }
        });
        
        // Touch events
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            touches.startX = x;
            touches.startY = y;
            touches.currentX = x;
            touches.currentY = y;
            
            if (game.mode === 'exploration') {
                // Check if touch is in movement area (left side of screen)
                if (x < canvas.width / 3) {
                    touches.joystickActive = true;
                    touches.isMoving = true;
                }
                // Right side for interaction
                else if (x > canvas.width * 2/3) {
                    // Simulate space key for interaction
                    keys[' '] = true;
                    setTimeout(() => keys[' '] = false, 100);
                }
            } else if (game.mode === 'combat') {
                // Combat touch zones
                if (x < canvas.width / 4) {
                    // Left movement
                    keys['a'] = true;
                } else if (x > canvas.width * 3/4) {
                    // Right movement
                    keys['d'] = true;
                } else if (y < canvas.height / 2) {
                    // Upper middle - Empty Palm
                    keys[' '] = true;
                } else {
                    // Lower middle - Attack
                    if (x < canvas.width / 2) {
                        keys['j'] = true; // Punch
                    } else {
                        keys['k'] = true; // Kick
                    }
                }
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (!touches.isMoving) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touches.currentX = touch.clientX - rect.left;
            touches.currentY = touch.clientY - rect.top;
            
            if (touches.joystickActive && game.mode === 'exploration') {
                // Calculate direction from start point
                const dx = touches.currentX - touches.startX;
                const dy = touches.currentY - touches.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Reset all directions
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
                
                if (distance > 20) { // Dead zone
                    const angle = Math.atan2(dy, dx);
                    
                    // Convert angle to 8-way direction
                    if (angle > -Math.PI/8 && angle <= Math.PI/8) {
                        keys['d'] = true; // Right
                    } else if (angle > Math.PI/8 && angle <= 3*Math.PI/8) {
                        keys['d'] = true;
                        keys['s'] = true; // Down-Right
                    } else if (angle > 3*Math.PI/8 && angle <= 5*Math.PI/8) {
                        keys['s'] = true; // Down
                    } else if (angle > 5*Math.PI/8 && angle <= 7*Math.PI/8) {
                        keys['a'] = true;
                        keys['s'] = true; // Down-Left
                    } else if (angle > 7*Math.PI/8 || angle <= -7*Math.PI/8) {
                        keys['a'] = true; // Left
                    } else if (angle > -7*Math.PI/8 && angle <= -5*Math.PI/8) {
                        keys['a'] = true;
                        keys['w'] = true; // Up-Left
                    } else if (angle > -5*Math.PI/8 && angle <= -3*Math.PI/8) {
                        keys['w'] = true; // Up
                    } else if (angle > -3*Math.PI/8 && angle <= -Math.PI/8) {
                        keys['d'] = true;
                        keys['w'] = true; // Up-Right
                    }
                }
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            touches.isMoving = false;
            touches.joystickActive = false;
            
            // Clear all movement keys
            if (game.mode === 'exploration') {
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            } else if (game.mode === 'combat') {
                // Clear combat keys
                keys['a'] = keys['d'] = keys['j'] = keys['k'] = keys[' '] = false;
            }
        }

        // Save Menu Functions
        function openSaveMenu() {
            const menu = document.getElementById('saveMenu');
            const slotsDiv = document.getElementById('saveSlots');
            
            // Clear and populate slots
            slotsDiv.innerHTML = '';
            
            for (let i = 1; i <= 3; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.style.cssText = 'margin: 10px 0; padding: 15px; border: 2px solid #666; background: #111;';
                
                const saveInfo = getSaveInfo(i);
                
                if (saveInfo) {
                    const date = new Date(saveInfo.timestamp);
                    slotDiv.innerHTML = `
                        <h3>Slot ${i} ${i === game.saveSlot ? '(Current)' : ''}</h3>
                        <p>${saveInfo.advancement} - Madra: ${saveInfo.madraCollected} - Wins: ${saveInfo.combatWins}</p>
                        <p>Saved: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}</p>
                        <button onclick="saveToSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Save Here</button>
                        <button onclick="loadFromSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Load</button>
                        <button onclick="deleteSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer; background: #f00;">Delete</button>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <h3>Slot ${i} - Empty</h3>
                        <button onclick="saveToSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Save Here</button>
                    `;
                }
                
                slotsDiv.appendChild(slotDiv);
            }
            
            menu.style.display = 'block';
            game.paused = true;
        }

        function closeSaveMenu() {
            document.getElementById('saveMenu').style.display = 'none';
            game.paused = false;
        }

        function saveToSlot(slot) {
            game.saveSlot = slot;
            saveGame(slot);
            openSaveMenu(); // Refresh menu
        }

        function loadFromSlot(slot) {
            game.saveSlot = slot;
            if (loadGame(slot)) {
                closeSaveMenu();
            }
        }

        function deleteSlot(slot) {
            if (confirm(`Delete save in slot ${slot}?`)) {
                deleteSave(slot);
                openSaveMenu(); // Refresh menu
            }
        }

        // Generate world based on game mode
        function generateWorld() {
            // Clear existing world
            game.world.tiles = [];
            game.world.entities = [];
            game.world.npcs = [];
            
            if (game.mode === 'tutorial') {
                generateTutorialWorld();
            } else {
                generateExplorationWorld();
            }
        }
        
        // Generate tutorial world (Sacred Valley)
        function generateTutorialWorld() {
            const stage = game.tutorialStage;
            
            if (stage === 'clanGrounds') {
                // Wei Clan training grounds
                game.world.width = 800;
                game.world.height = 600;
                
                // Create training area
                for (let y = 0; y < game.world.height; y += 40) {
                    for (let x = 0; x < game.world.width; x += 40) {
                        game.world.tiles.push({
                            x: x,
                            y: y,
                            type: 'dojo'
                        });
                    }
                }
                
                // Add training dummies
                game.world.entities.push({
                    type: 'trainingDummy',
                    x: 200,
                    y: 300,
                    health: 999,
                    respawn: true
                });
                
                // Add Kelsa
                game.world.npcs.push({
                    name: 'Wei Shi Kelsa',
                    x: 400,
                    y: 200,
                    dialogue: [
                        "Little brother, you need to practice your Empty Palm.",
                        "Focus your madra and strike the training dummy.",
                        "Remember, pure madra disrupts, it doesn't destroy."
                    ],
                    path: 'White Fox'
                });
                
                // Add path instructors
                game.world.npcs.push({
                    name: 'Wei Instructor',
                    x: 600,
                    y: 300,
                    dialogue: [
                        "Ready to choose your path?",
                        "We have Empty Palm and White Fox available in the Wei clan."
                    ],
                    questTrigger: 'pathChoice'
                });
                
            } else if (stage === 'tournament') {
                // Tournament arena
                game.world.width = 800;
                game.world.height = 600;
                
                // Create arena floor
                for (let y = 0; y < game.world.height; y += 40) {
                    for (let x = 0; x < game.world.width; x += 40) {
                        game.world.tiles.push({
                            x: x,
                            y: y,
                            type: 'arena'
                        });
                    }
                }
                
                // Add spectators (NPCs)
                const spectatorNames = ['Wei Mon Keth', 'Elder Whisper', 'Wei Shi Jaran'];
                spectatorNames.forEach((name, i) => {
                    game.world.npcs.push({
                        name: name,
                        x: 100 + i * 200,
                        y: 100,
                        dialogue: ["The Seven-Year Festival begins!"],
                        spectator: true
                    });
                });
            }
        }
        
        // Generate normal exploration world
        function generateExplorationWorld() {
            // Create tile map
            for (let y = 0; y < game.world.height; y += 40) {
                for (let x = 0; x < game.world.width; x += 40) {
                    const tile = {
                        x: x,
                        y: y,
                        type: 'grass'
                    };
                    
                    // Add some variety
                    if (Math.random() < 0.1) tile.type = 'stone';
                    if (Math.random() < 0.05) tile.type = 'flower';
                    
                    game.world.tiles.push(tile);
                }
            }

            // Add walls (boundaries)
            for (let x = 0; x < game.world.width; x += 40) {
                game.world.tiles.push({ x: x, y: 0, type: 'wall' });
                game.world.tiles.push({ x: x, y: game.world.height - 40, type: 'wall' });
            }
            for (let y = 0; y < game.world.height; y += 40) {
                game.world.tiles.push({ x: 0, y: y, type: 'wall' });
                game.world.tiles.push({ x: game.world.width - 40, y: y, type: 'wall' });
            }

            // Add madra orbs
            for (let i = 0; i < 20; i++) {
                game.world.entities.push({
                    type: 'madra',
                    x: Math.random() * (game.world.width - 100) + 50,
                    y: Math.random() * (game.world.height - 100) + 50,
                    collected: false,
                    pulse: 0
                });
            }

            // Add enemies
            const enemyTypes = ['student', 'iron', 'jade'];
            for (let i = 0; i < 8; i++) {
                game.world.entities.push({
                    type: 'enemy',
                    enemyType: enemyTypes[Math.floor(Math.random() * enemyTypes.length)],
                    x: Math.random() * (game.world.width - 200) + 100,
                    y: Math.random() * (game.world.height - 200) + 100,
                    health: 100,
                    patrol: {
                        startX: 0,
                        startY: 0,
                        direction: 1
                    }
                });
            }

            // Add NPCs
            game.world.npcs.push({
                name: 'Elder Whisper',
                x: 800,
                y: 600,
                dialogue: [
                    "The path of the Unsouled is difficult, but not impossible.",
                    "Collect madra from the sacred orbs scattered across the valley.",
                    "Prove yourself in combat, and perhaps you'll advance beyond Copper."
                ]
            });

            // Initialize enemy patrols
            game.world.entities.forEach(entity => {
                if (entity.type === 'enemy') {
                    entity.patrol.startX = entity.x;
                    entity.patrol.startY = entity.y;
                }
            });
        }

        // Update exploration mode
        function updateExploration() {
            if (game.paused) return;
            
            // Player movement
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy = -game.player.speed;
            if (keys['s'] || keys['arrowdown']) dy = game.player.speed;
            if (keys['a'] || keys['arrowleft']) dx = -game.player.speed;
            if (keys['d'] || keys['arrowright']) dx = game.player.speed;

            // Check collision with walls
            const newX = game.player.x + dx;
            const newY = game.player.y + dy;
            
            let canMove = true;
            game.world.tiles.forEach(tile => {
                if (tile.type === 'wall') {
                    if (newX < tile.x + 40 && newX + 20 > tile.x &&
                        newY < tile.y + 40 && newY + 20 > tile.y) {
                        canMove = false;
                    }
                }
            });

            if (canMove) {
                game.player.x = Math.max(20, Math.min(game.world.width - 40, newX));
                game.player.y = Math.max(20, Math.min(game.world.height - 40, newY));
            }

            // Update camera to follow player
            game.camera.x = Math.max(0, Math.min(game.world.width - canvas.width, 
                game.player.x - canvas.width / 2));
            game.camera.y = Math.max(0, Math.min(game.world.height - canvas.height, 
                game.player.y - canvas.height / 2));

            // Check entity interactions
            game.world.entities.forEach(entity => {
                const dist = Math.hypot(entity.x - game.player.x, entity.y - game.player.y);
                
                if (entity.type === 'madra' && !entity.collected && dist < 30) {
                    entity.collected = true;
                    game.player.madraCollected += 10;
                    game.player.madra = Math.min(game.player.maxMadra, game.player.madra + 20);
                    createFloatingText('+10 Madra', entity.x - game.camera.x, entity.y - game.camera.y);
                    checkAdvancement();
                }
                
                if (entity.type === 'enemy' && dist < 40) {
                    startCombat(entity);
                }
                
                if (entity.type === 'trainingDummy' && dist < 40 && keys[' ']) {
                    // Practice on training dummy
                    if (game.player.techniques.includes('emptyPalm')) {
                        createFloatingText('DISRUPTED!', entity.x - game.camera.x, entity.y - game.camera.y);
                        showDialogue("Good! The Empty Palm disrupts madra flow. Now speak to the instructor.", "Wei Shi Kelsa");
                    }
                }

                // Update entity animations
                if (entity.type === 'madra' && !entity.collected) {
                    entity.pulse += 0.1;
                }
                
                if (entity.type === 'enemy') {
                    // Simple patrol AI
                    entity.x += entity.patrol.direction * 0.5;
                    if (Math.abs(entity.x - entity.patrol.startX) > 100) {
                        entity.patrol.direction *= -1;
                    }
                }
            });

            // NPC interaction
            if (keys[' '] && (!game.dialogue || !game.dialogue.active)) {
                game.world.npcs.forEach(npc => {
                    const dist = Math.hypot(npc.x - game.player.x, npc.y - game.player.y);
                    if (dist < 50) {
                        if (npc.questTrigger === 'pathChoice' && game.player.path === 'none') {
                            showPathChoice();
                        } else if (npc.dialogue && npc.dialogue.length > 0) {
                            const dialogueIndex = Math.floor(Math.random() * npc.dialogue.length);
                            showDialogue(npc.dialogue[dialogueIndex], npc.name);
                        }
                    }
                });
            }
            
            // Close dialogue with space or escape
            if ((keys[' '] || keys['escape']) && game.dialogue && game.dialogue.active && !game.dialogue.choices) {
                hideDialogue();
                keys[' '] = false; // Prevent immediate re-trigger
            }
        }
        
        // Tutorial progression
        function progressTutorial() {
            if (game.tutorialStage === 'clanGrounds' && game.player.path !== 'none') {
                game.tutorialStage = 'tournament';
                generateWorld();
                game.player.x = 400;
                game.player.y = 400;
                
                setTimeout(() => {
                    showDialogue("The Seven-Year Festival tournament begins! Face your first opponent!", "Wei Mon Keth");
                    setTimeout(() => {
                        startTournamentBattle(0);
                    }, 3000);
                }, 1000);
            }
        }
        
        // Start tournament battle
        function startTournamentBattle(round) {
            if (round >= game.tournament.opponents.length) {
                // Tournament complete (or interrupted)
                return;
            }
            
            const opponent = game.tournament.opponents[round];
            game.tournament.round = round;
            game.combat.currentOpponent = opponent;
            
            // Special handling for Li Markuth
            if (opponent.name === 'Li Markuth') {
                showDialogue("IMPOSSIBLE! A Jade in Sacred Valley?!", "Wei Mon Keth");
                setTimeout(() => {
                    showSurielVision();
                }, 3000);
                return;
            }
            
            // Start normal tournament fight
            game.mode = 'combat';
            game.combat.enemyType = opponent.path;
            game.combat.enemyHealth = game.combat.enemyMaxHealth = opponent.health;
            game.combat.playerX = 200;
            game.combat.enemyX = 600;
            game.combat.playerY = game.combat.enemyY = 400;
            game.combat.playerState = game.combat.enemyState = 'idle';
            game.combat.combo = 0;
            
            document.getElementById('explorationInstructions').style.display = 'none';
            document.getElementById('combatInstructions').style.display = 'block';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('combatUI').style.display = 'block';
            document.getElementById('enemyName').textContent = opponent.name;
            
            // Switch mobile controls
            if (isMobile) {
                document.getElementById('explorationControls').style.display = 'none';
                document.getElementById('combatControls').style.display = 'block';
            }
            
            flashScreen();
        }
        
        // Suriel's vision sequence
        function showSurielVision() {
            game.paused = true;
            
            // Create vision overlay
            const visionDiv = document.createElement('div');
            visionDiv.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle, rgba(0,100,200,0.8) 0%, rgba(0,0,50,0.95) 100%);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                color: white;
                font-size: 24px;
                text-align: center;
                z-index: 1000;
                animation: fadeIn 2s;
            `;
            
            visionDiv.innerHTML = `
                <h1 style="color: #00ccff; margin-bottom: 30px;">FATE INTERVENTION</h1>
                <p style="margin: 20px; max-width: 600px;">A presence beyond your comprehension freezes time itself...</p>
                <p style="margin: 20px; max-width: 600px; color: #00ff88;">"Wei Shi Lindon. Your fate branches here. Will you remain Unsouled forever, or will you seek power beyond Sacred Valley?"</p>
                <button onclick="endTutorial()" style="margin-top: 40px; padding: 20px 40px; font-size: 20px; background: #00ff88; border: none; cursor: pointer; color: black; font-weight: bold;">LEAVE SACRED VALLEY</button>
            `;
            
            document.getElementById('gameContainer').appendChild(visionDiv);
        }
        
        // End tutorial and start main game
        window.endTutorial = function() {
            game.mode = 'exploration';
            game.tutorialStage = 'complete';
            game.player.advancement = 'Copper'; // Advancement begins!
            generateWorld(); // Generate the full world
            
            // Remove vision overlay
            const visions = document.querySelectorAll('[style*="radial-gradient"]');
            visions.forEach(v => v.remove());
            
            game.paused = false;
            showDialogue("You have left Sacred Valley. Your true journey begins now!");
            showAdvancement('Copper');
        };

        // Start combat
        function startCombat(enemy) {
            game.mode = 'combat';
            game.combat.enemyType = enemy.enemyType;
            game.combat.enemyHealth = game.combat.enemyMaxHealth = enemy.health;
            game.combat.playerX = 200;
            game.combat.enemyX = 600;
            game.combat.playerY = game.combat.enemyY = 400;
            game.combat.playerState = game.combat.enemyState = 'idle';
            game.combat.combo = 0;
            
            document.getElementById('explorationInstructions').style.display = 'none';
            document.getElementById('combatInstructions').style.display = 'block';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('combatUI').style.display = 'block';
            document.getElementById('enemyName').textContent = enemy.enemyType.toUpperCase();
            
            // Switch mobile controls
            if (isMobile) {
                document.getElementById('explorationControls').style.display = 'none';
                document.getElementById('combatControls').style.display = 'block';
            }
            
            flashScreen();
            
            // Remove enemy from world after combat starts
            const index = game.world.entities.indexOf(enemy);
            if (index > -1) {
                game.world.entities.splice(index, 1);
            }
        }

        // Update combat mode
        function updateCombat() {
            // Player controls
            if (keys['a']) {
                game.combat.playerX = Math.max(50, game.combat.playerX - 5);
                game.combat.playerFacing = -1;
            }
            if (keys['d']) {
                game.combat.playerX = Math.min(400, game.combat.playerX + 5);
                game.combat.playerFacing = 1;
            }
            
            // Combat actions
            if (keys['j'] && game.combat.playerState === 'idle') {
                performAttack('punch', 10, 0);
            }
            if (keys['k'] && game.combat.playerState === 'idle') {
                performAttack('kick', 15, 0);
            }
            if (keys[' '] && game.combat.playerState === 'idle' && game.player.madra >= 30) {
                performAttack('emptyPalm', 0, 30); // NO DAMAGE - Lore accurate!
            }
            
            game.combat.blockActive = keys['l'];

            // Update combat states
            if (game.combat.playerState === 'attacking') {
                setTimeout(() => {
                    game.combat.playerState = 'idle';
                }, 300);
            }

            // Enemy AI with stun handling
            const distance = Math.abs(game.combat.enemyX - game.combat.playerX);
            
            // Check if enemy is stunned
            if (game.combat.enemyStunnedUntil && Date.now() < game.combat.enemyStunnedUntil) {
                game.combat.enemyState = 'stunned';
                // Enemy can't act while stunned - this is your window!
            } else if (game.combat.enemyState === 'stunned') {
                // Stun wore off
                game.combat.enemyState = 'idle';
                game.combat.enemyStunnedUntil = null;
            }
            
            // Normal enemy behavior (only if not stunned)
            if (game.combat.enemyState === 'idle') {
                if (distance > 100) {
                    // Move towards player
                    game.combat.enemyX += game.combat.enemyX > game.combat.playerX ? -3 : 3;
                } else if (Math.random() < 0.02) {
                    // Attack
                    game.combat.enemyState = 'attacking';
                    setTimeout(() => {
                        if (distance < 100 && !game.combat.blockActive && game.combat.enemyState !== 'stunned') {
                            game.player.health = Math.max(0, game.player.health - 10);
                            game.combat.combo = 0;
                            screenShake();
                        }
                        if (game.combat.enemyState !== 'stunned') {
                            game.combat.enemyState = 'idle';
                        }
                    }, 400);
                }
            }

            // Check win/loss
            if (game.combat.enemyHealth <= 0) {
                endCombat(true);
            } else if (game.player.health <= 0) {
                endCombat(false);
            }

            // Update UI
            document.getElementById('combatPlayerHealth').style.width = 
                (game.player.health / game.player.maxHealth * 100) + '%';
            document.getElementById('combatPlayerMadra').style.width = 
                (game.player.madra / game.player.maxMadra * 100) + '%';
            document.getElementById('combatEnemyHealth').style.width = 
                (game.combat.enemyHealth / game.combat.enemyMaxHealth * 100) + '%';
        }

        // Perform attack
        function performAttack(type, damage, madraCost) {
            game.combat.playerState = 'attacking';
            
            const distance = Math.abs(game.combat.enemyX - game.combat.playerX);
            
            if (type === 'emptyPalm') {
                // LORE-ACCURATE EMPTY PALM - No damage, pure disruption
                if (game.player.madra >= 30) {
                    game.player.madra -= 30;
                    
                    // Calculate stun duration based on advancement
                    let stunDuration = 500; // 0.5 seconds base
                    if (game.player.advancement === 'Copper') stunDuration = 1000;
                    if (game.player.advancement === 'Iron') stunDuration = 1500;
                    if (game.player.advancement === 'Jade') stunDuration = 2000;
                    if (game.player.advancement === 'Gold') stunDuration = 2500;
                    
                    // Apply disruption effects
                    game.combat.enemyState = 'stunned';
                    game.combat.enemyStunnedUntil = Date.now() + stunDuration;
                    
                    // Visual feedback
                    flashScreen();
                    createFloatingText('DISRUPTED!', game.combat.enemyX, game.combat.enemyY - 50);
                    
                    // Interrupt any enemy attack in progress
                    if (game.combat.enemyState === 'attacking') {
                        game.combat.enemyState = 'stunned';
                    }
                    
                    // Drain enemy madra (if they have any)
                    if (game.combat.enemyMadra !== undefined) {
                        game.combat.enemyMadra = Math.max(0, game.combat.enemyMadra - 20);
                    }
                    
                    // Window of opportunity for follow-up
                    game.combat.emptyPalmWindow = true;
                    setTimeout(() => {
                        game.combat.emptyPalmWindow = false;
                    }, stunDuration);
                }
            } else if (distance < 100) {
                // Regular attacks do MORE damage during Empty Palm stun window
                let finalDamage = damage;
                if (game.combat.emptyPalmWindow) {
                    finalDamage = Math.floor(damage * 1.5); // 50% more damage
                    createFloatingText('CRITICAL!', game.combat.enemyX, game.combat.enemyY - 80);
                }
                
                game.combat.enemyHealth = Math.max(0, game.combat.enemyHealth - finalDamage);
                game.combat.combo++;
                game.combat.lastHit = Date.now();
                
                // Show combo
                if (game.combat.combo > 1) {
                    document.getElementById('comboCount').textContent = game.combat.combo;
                    document.getElementById('comboCounter').style.display = 'block';
                }
                
                screenShake();
                createFloatingText(finalDamage + ' DMG', game.combat.enemyX, game.combat.enemyY - 50);
            }
        }

        // End combat
        function endCombat(victory) {
            // Store current mode before changing
            const wasInTutorial = game.mode === 'tutorial';
            
            game.mode = wasInTutorial ? 'tutorial' : 'exploration';
            document.getElementById('explorationInstructions').style.display = 'block';
            document.getElementById('combatInstructions').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('combatUI').style.display = 'none';
            document.getElementById('comboCounter').style.display = 'none';
            
            // Switch mobile controls back
            if (isMobile) {
                document.getElementById('explorationControls').style.display = 'block';
                document.getElementById('combatControls').style.display = 'none';
            }
            
            if (victory) {
                // Check if this was a tournament battle
                if (wasInTutorial && game.combat.currentOpponent) {
                    const round = game.tournament.round;
                    showDialogue(`Victory against ${game.combat.currentOpponent.name}!`, "Wei Mon Keth");
                    
                    setTimeout(() => {
                        if (round + 1 < game.tournament.opponents.length) {
                            startTournamentBattle(round + 1);
                        }
                    }, 3000);
                } else {
                    // Normal combat victory
                    game.player.combatWins++;
                    game.player.madraCollected += 50;
                    game.player.health = Math.min(game.player.maxHealth, game.player.health + 20);
                    showDialogue("Victory! You've gained strength from combat.");
                    checkAdvancement();
                    // Auto-save after victory
                    if (typeof saveGame === 'function') {
                        saveGame();
                    }
                }
            } else {
                game.player.health = game.player.maxHealth;
                game.player.x = 400;
                game.player.y = 300;
                showDialogue("Defeated... but you rise again, determined.");
            }
            
            updateUI();
        }

        // Check for advancement
        function checkAdvancement() {
            const advancements = [
                { name: 'Copper', madra: 100, wins: 2 },
                { name: 'Iron', madra: 300, wins: 5 },
                { name: 'Jade', madra: 600, wins: 10 },
                { name: 'Gold', madra: 1000, wins: 20 }
            ];
            
            advancements.forEach(level => {
                if (game.player.advancement !== level.name && 
                    game.player.madraCollected >= level.madra && 
                    game.player.combatWins >= level.wins) {
                    game.player.advancement = level.name;
                    game.player.maxHealth += 50;
                    game.player.maxMadra += 50;
                    game.player.health = game.player.maxHealth;
                    game.player.madra = game.player.maxMadra;
                    game.player.speed += 1;
                    
                    showAdvancement(level.name);
                }
            });
        }

        // Show advancement notification
        function showAdvancement(level) {
            const notice = document.getElementById('advancementNotice');
            notice.innerHTML = `ADVANCEMENT!<br>You have reached ${level}!`;
            notice.style.display = 'block';
            flashScreen();
            
            setTimeout(() => {
                notice.style.display = 'none';
            }, 3000);
        }

        // Render functions
        function render() {
            // Clear with black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Only render game content if not showing Suriel vision
            if (!document.querySelector('[style*="radial-gradient"]')) {
                if (game.mode === 'exploration' || game.mode === 'tutorial') {
                    renderExploration();
                } else {
                    renderCombat();
                }
            }
        }

        function renderExploration() {
            // Render tiles
            game.world.tiles.forEach(tile => {
                const screenX = tile.x - game.camera.x;
                const screenY = tile.y - game.camera.y;
                
                if (screenX > -40 && screenX < canvas.width && 
                    screenY > -40 && screenY < canvas.height) {
                    
                    ctx.fillStyle = tile.type === 'grass' ? '#2d5016' : 
                                   tile.type === 'stone' ? '#444' :
                                   tile.type === 'flower' ? '#2d5016' : '#222';
                    ctx.fillRect(screenX, screenY, 40, 40);
                    
                    if (tile.type === 'flower') {
                        ctx.fillStyle = '#ff69b4';
                        ctx.fillRect(screenX + 15, screenY + 15, 10, 10);
                    }
                }
            });

            // Render entities
            game.world.entities.forEach(entity => {
                const screenX = entity.x - game.camera.x;
                const screenY = entity.y - game.camera.y;
                
                if (entity.type === 'madra' && !entity.collected) {
                    const pulse = Math.sin(entity.pulse) * 5;
                    ctx.fillStyle = '#00ccff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ccff';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 15 + pulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                if (entity.type === 'enemy') {
                    // Enemy body
                    ctx.fillStyle = entity.enemyType === 'student' ? '#654321' :
                                   entity.enemyType === 'iron' ? '#888' : '#0f0';
                    ctx.fillRect(screenX - 15, screenY - 30, 30, 40);
                    
                    // Enemy head
                    ctx.fillStyle = '#fdbcb4';
                    ctx.fillRect(screenX - 10, screenY - 40, 20, 20);
                }
            });

            // Render NPCs
            game.world.npcs.forEach(npc => {
                const screenX = npc.x - game.camera.x;
                const screenY = npc.y - game.camera.y;
                
                // NPC body (Elder)
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(screenX - 20, screenY - 40, 40, 50);
                
                // NPC head
                ctx.fillStyle = '#fdbcb4';
                ctx.fillRect(screenX - 15, screenY - 55, 30, 25);
                
                // Name tag
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(npc.name, screenX, screenY - 65);
            });

            // Render player
            const playerScreenX = game.player.x - game.camera.x;
            const playerScreenY = game.player.y - game.camera.y;
            
            // Player body
            ctx.fillStyle = game.player.advancement === 'Unsouled' ? '#333' :
                           game.player.advancement === 'Copper' ? '#b87333' :
                           game.player.advancement === 'Iron' ? '#888' :
                           game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
            ctx.fillRect(playerScreenX - 10, playerScreenY - 20, 20, 30);
            
            // Player head
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(playerScreenX - 8, playerScreenY - 30, 16, 16);
            
            // Advancement aura
            if (game.player.advancement !== 'Unsouled') {
                ctx.strokeStyle = game.player.advancement === 'Copper' ? '#b87333' :
                                 game.player.advancement === 'Iron' ? '#888' :
                                 game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(playerScreenX - 15, playerScreenY - 35, 30, 40);
            }
        }

        function renderCombat() {
            // Combat arena background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ground
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 450, canvas.width, 150);
            
            // Render player
            ctx.save();
            ctx.translate(game.combat.playerX, game.combat.playerY);
            ctx.scale(game.combat.playerFacing, 1);
            
            // Player sprite
            ctx.fillStyle = game.player.advancement === 'Unsouled' ? '#333' :
                           game.player.advancement === 'Copper' ? '#b87333' :
                           game.player.advancement === 'Iron' ? '#888' :
                           game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
            ctx.fillRect(-20, -60, 40, 60);
            
            // Head
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-15, -75, 30, 25);
            
            // Attack effect
            if (game.combat.playerState === 'attacking') {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(20, -40, 30, 10);
            }
            
            // Block shield
            if (game.combat.blockActive) {
                ctx.strokeStyle = '#00f';
                ctx.lineWidth = 3;
                ctx.strokeRect(-30, -80, 60, 80);
            }
            
            ctx.restore();
            
            // Render enemy
            ctx.save();
            ctx.translate(game.combat.enemyX, game.combat.enemyY);
            
            // Enemy sprite
            ctx.fillStyle = game.combat.enemyType === 'student' ? '#654321' :
                           game.combat.enemyType === 'iron' ? '#888' : '#0f0';
            ctx.fillRect(-20, -60, 40, 60);
            
            // Head
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-15, -75, 30, 25);
            
            // Stun effect visual
            if (game.combat.enemyState === 'stunned') {
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
                ctx.strokeRect(-25, -80, 50, 80);
                ctx.globalAlpha = 1;
                
                // Disruption particles
                for (let i = 0; i < 3; i++) {
                    const angle = (Date.now() * 0.01 + i * 2) % (Math.PI * 2);
                    const x = Math.cos(angle) * 30;
                    const y = Math.sin(angle) * 30 - 40;
                    ctx.fillStyle = '#00ccff';
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                }
            }
            
            // Attack effect
            if (game.combat.enemyState === 'attacking') {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(-50, -40, 30, 10);
            }
            
            ctx.restore();
        }

        // UI functions
        function updateUI() {
            document.getElementById('advancement').textContent = game.player.advancement;
            document.getElementById('playerHealth').style.width = 
                (game.player.health / game.player.maxHealth * 100) + '%';
            document.getElementById('playerMadra').style.width = 
                (game.player.madra / game.player.maxMadra * 100) + '%';
            document.getElementById('madraCount').textContent = game.player.madraCollected;
            document.getElementById('winCount').textContent = game.player.combatWins;
        }

        // Dialogue system
        function showDialogue(text, speaker = '') {
            if (!game.dialogue) {
                game.dialogue = {
                    active: false,
                    speaker: '',
                    text: '',
                    queue: [],
                    choices: null
                };
            }
            
            game.dialogue.active = true;
            game.dialogue.text = text;
            game.dialogue.speaker = speaker;
            game.paused = true;
            
            const dialogueDiv = document.getElementById('dialogue');
            if (dialogueDiv) {
                dialogueDiv.innerHTML = speaker ? `<strong>${speaker}:</strong> ${text}` : text;
                dialogueDiv.style.display = 'block';
            }
        }
        
        function hideDialogue() {
            if (game.dialogue) {
                game.dialogue.active = false;
            }
            game.paused = false;
            const dialogueDiv = document.getElementById('dialogue');
            if (dialogueDiv) {
                dialogueDiv.style.display = 'none';
            }
        }
        
        function showPathChoice() {
            const choices = `
                <div style="text-align: center;">
                    <h3>Choose Your Sacred Valley Path</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                        <button onclick="choosePath('emptyPalm')" style="padding: 20px; cursor: pointer; background: #222; border: 2px solid #00ff88; color: white;">
                            <strong>Empty Palm</strong><br>
                            Pure madra disruption<br>
                            <small>Wei Clan foundation</small>
                        </button>
                        <button onclick="choosePath('whiteFox')" style="padding: 20px; cursor: pointer; background: #222; border: 2px solid #ff69b4; color: white;">
                            <strong>White Fox</strong><br>
                            Illusion and deception<br>
                            <small>Wei Clan dream path</small>
                        </button>
                        <button onclick="choosePath('ironHeart')" style="padding: 20px; cursor: pointer; background: #222; border: 2px solid #888; color: white;">
                            <strong>Iron Heart</strong><br>
                            Body reinforcement<br>
                            <small>Kazan Clan strength</small>
                        </button>
                        <button onclick="choosePath('fallenLeaf')" style="padding: 20px; cursor: pointer; background: #222; border: 2px solid #8b4513; color: white;">
                            <strong>Fallen Leaf</strong><br>
                            Speed and stealth<br>
                            <small>Li Clan movement</small>
                        </button>
                    </div>
                </div>
            `;
            
            const dialogueDiv = document.getElementById('dialogue');
            dialogueDiv.innerHTML = choices;
            dialogueDiv.style.display = 'block';
            dialogueDiv.style.maxWidth = '800px';
            game.paused = true;
        }
        
        function choosePath(path) {
            game.player.path = path;
            
            // Update player based on path
            switch(path) {
                case 'emptyPalm':
                    game.player.techniques = ['emptyPalm'];
                    showDialogue("You continue on the Path of Empty Palm. Pure madra is your weapon.", "Wei Instructor");
                    break;
                case 'whiteFox':
                    game.player.techniques = ['foxDream'];
                    game.player.name = 'Wei Shi Student';
                    showDialogue("You've chosen the White Fox path. Deception and illusion will be your tools.", "Wei Instructor");
                    break;
                case 'ironHeart':
                    game.player.techniques = ['ironBody'];
                    game.player.name = 'Kazan Student';
                    game.player.maxHealth = 150;
                    game.player.health = 150;
                    showDialogue("The Iron Heart path strengthens your body beyond normal limits.", "Kazan Instructor");
                    break;
                case 'fallenLeaf':
                    game.player.techniques = ['leafStep'];
                    game.player.name = 'Li Student';
                    game.player.speed = 5;
                    showDialogue("The Fallen Leaf path grants speed and grace in movement.", "Li Instructor");
                    break;
            }
            
            setTimeout(() => {
                hideDialogue();
                progressTutorial();
            }, 3000);
        }
        
        // Make choosePath global
        window.choosePath = choosePath;

        function createFloatingText(text, x, y) {
            const div = document.createElement('div');
            div.className = 'floatingText';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.getElementById('gameContainer').appendChild(div);
            
            setTimeout(() => {
                div.remove();
            }, 1000);
        }

        function flashScreen() {
            const flash = document.getElementById('screenFlash');
            flash.style.opacity = '0.8';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 100);
        }

        let shakeAmount = 0;
        function screenShake() {
            shakeAmount = 10;
        }

        // Fullscreen functionality
        function toggleFullscreen() {
            const container = document.getElementById('gameContainer');
            
            if (!document.fullscreenElement) {
                // Try multiple methods for better compatibility
                const requestFullscreen = container.requestFullscreen || 
                                        container.mozRequestFullScreen || 
                                        container.webkitRequestFullscreen || 
                                        container.msRequestFullscreen;
                
                if (requestFullscreen) {
                    requestFullscreen.call(container).then(() => {
                        document.getElementById('fullscreenBtn').textContent = '⛶ Exit Fullscreen';
                        resizeCanvas();
                    }).catch(err => {
                        // Silently fail or show user-friendly message
                        console.log('Fullscreen not available in this environment');
                        // Optionally hide the fullscreen button if not supported
                        const btn = document.getElementById('fullscreenBtn');
                        if (btn) btn.style.display = 'none';
                    });
                }
            } else {
                const exitFullscreen = document.exitFullscreen || 
                                     document.mozCancelFullScreen || 
                                     document.webkitExitFullscreen || 
                                     document.msExitFullscreen;
                
                if (exitFullscreen) {
                    exitFullscreen.call(document).then(() => {
                        document.getElementById('fullscreenBtn').textContent = '⛶ Fullscreen';
                        resizeCanvas();
                    });
                }
            }
        }
        
        // Update canvas on fullscreen change
        document.addEventListener('fullscreenchange', resizeCanvas);
        
        // Make function global
        window.toggleFullscreen = toggleFullscreen;
        
        // Game loop
        function gameLoop() {
            // Skip updates if paused
            if (!game.paused) {
                // Update based on game mode
                if (game.mode === 'tutorial' || game.mode === 'exploration') {
                    updateExploration();
                    autoSave(); // Check for auto-save
                } else if (game.mode === 'combat') {
                    updateCombat();
                }
                
                updateUI();
                
                // Handle screen shake with proper transform
                if (shakeAmount > 0) {
                    const shakeX = (Math.random() - 0.5) * shakeAmount;
                    const shakeY = (Math.random() - 0.5) * shakeAmount;
                    const currentTransform = canvas.style.transform;
                    canvas.style.transform = currentTransform + ` translate(${shakeX}px, ${shakeY}px)`;
                    shakeAmount *= 0.9;
                } else {
                    // Reset to centered position
                    canvas.style.transform = 'translate(-50%, -50%)';
                }
                
                // Handle combo timeout
                if (Date.now() - game.combat.lastHit > 2000) {
                    game.combat.combo = 0;
                    document.getElementById('comboCounter').style.display = 'none';
                }
                
                // Render
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        testSaveMethod(); // Test which save method to use
        generateWorld();
        
        // Initialize mobile controls
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('instructions').style.display = 'none';
            initializeMobileControls();
        }
        
        // Show quick help on first load (define function before calling)
        let helpShown = false;
        window.showQuickHelp = function() {
            if (!helpShown) {
                const quickHelp = document.getElementById('quickHelp');
                if (quickHelp) {
                    quickHelp.style.display = 'block';
                    setTimeout(() => {
                        quickHelp.style.display = 'none';
                    }, 5000);
                    helpShown = true;
                }
            }
        };
        
        // Try to load save on start
        if (saveMethod !== 'none' && getSaveInfo(1)) {
            const shouldLoad = confirm("Save file found! Load your progress?");
            if (shouldLoad) {
                loadGame(1);
            }
        }
        
        game.lastSaveTime = Date.now();
        gameLoop();
        
        // Initial dialogue for tutorial
        setTimeout(() => {
            if (game.mode === 'tutorial') {
                showDialogue("Welcome to Sacred Valley, little brother. The Seven-Year Festival approaches.", "Wei Shi Kelsa");
                setTimeout(() => {
                    showDialogue("First, practice your Empty Palm technique on the training dummy. Press SPACE near it.", "Wei Shi Kelsa");
                }, 4000);
            } else if (saveMethod === 'memory') {
                showDialogue("Note: Browser storage blocked. Saves are temporary - download to keep them!");
            } else {
                showDialogue("Welcome to Sacred Valley. Prove yourself worthy of advancement!");
            }
            
            // Show quick help hint
            window.showQuickHelp();
        }, 1000);
        
        // Mobile control functions
        function initializeMobileControls() {
            // Virtual joystick for exploration
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                touches.joystickActive = true;
                touches.startX = rect.left + rect.width / 2;
                touches.startY = rect.top + rect.height / 2;
                updateJoystick(touch.clientX, touch.clientY);
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (touches.joystickActive) {
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                }
            });
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                touches.joystickActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            });
            
            // Action buttons
            document.getElementById('actionA').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            
            document.getElementById('actionA').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
            
            // Combat buttons
            document.getElementById('combatMoveLeft').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['a'] = true;
            });
            
            document.getElementById('combatMoveLeft').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['a'] = false;
            });
            
            document.getElementById('combatMoveRight').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['d'] = true;
            });
            
            document.getElementById('combatMoveRight').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['d'] = false;
            });
            
            document.getElementById('actionB').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['j'] = true;
            });
            
            document.getElementById('actionB').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['j'] = false;
            });
            
            document.getElementById('actionSpecial').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            
            document.getElementById('actionSpecial').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
        }
        
        function updateJoystick(touchX, touchY) {
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            const rect = joystick.getBoundingClientRect();
            
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = touchX - centerX;
            const dy = touchY - centerY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = rect.width / 2 - 20;
            
            let knobX = dx;
            let knobY = dy;
            
            if (distance > maxDistance) {
                knobX = (dx / distance) * maxDistance;
                knobY = (dy / distance) * maxDistance;
            }
            
            knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
            
            // Update movement keys
            keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            
            if (distance > 20) {
                const angle = Math.atan2(dy, dx);
                
                if (angle > -Math.PI/4 && angle <= Math.PI/4) {
                    keys['d'] = true;
                } else if (angle > Math.PI/4 && angle <= 3*Math.PI/4) {
                    keys['s'] = true;
                } else if (angle > 3*Math.PI/4 || angle <= -3*Math.PI/4) {
                    keys['a'] = true;
                } else {
                    keys['w'] = true;
                }
            }
        }
    </script>
</body>
</html>
