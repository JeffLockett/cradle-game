<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>üöÄ Flow State Recovery</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        
        :root {
            --primary: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --bg: #0a0a0a;
            --surface: #1a1a1a;
            --border: #333;
            --text: #f0f0f0;
        }
        
        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }
        
        header {
            background: var(--surface);
            padding: 12px;
            border-bottom: 3px solid var(--primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        h1 {
            font-size: 1.3rem;
            color: var(--primary);
        }
        
        .mode-indicator {
            font-size: 0.8rem;
            padding: 5px 10px;
            background: var(--primary);
            color: var(--bg);
            border-radius: 15px;
            font-weight: bold;
        }
        
        .container {
            padding: 15px;
            max-width: 600px;
            margin: 0 auto;
        }
        
        /* Quick Stats Bar */
        .stats-bar {
            background: var(--surface);
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-around;
            font-size: 0.9rem;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-weight: bold;
            color: var(--primary);
        }
        
        /* Compression Mode Selector */
        .mode-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .mode-btn {
            padding: 12px 8px;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 0.85rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .mode-btn.active {
            background: var(--primary);
            color: var(--bg);
            border-color: var(--primary);
        }
        
        .mode-btn .percent {
            display: block;
            font-size: 0.7rem;
            margin-top: 2px;
            opacity: 0.8;
        }
        
        /* Input/Output Areas */
        .panel {
            background: var(--surface);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        textarea {
            width: 100%;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            color: var(--text);
            font-family: monospace;
            font-size: 13px;
            resize: none;
            -webkit-appearance: none;
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        #inputArea {
            min-height: 200px;
        }
        
        #outputArea {
            min-height: 250px;
            border-color: var(--primary);
        }
        
        /* Action Buttons */
        .action-bar {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 12px;
        }
        
        button {
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            font-size: 0.9rem;
            cursor: pointer;
            -webkit-appearance: none;
            transition: all 0.2s;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        .btn-primary {
            background: var(--primary);
            color: var(--bg);
        }
        
        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 2px solid var(--primary);
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        .btn-full {
            grid-column: 1 / -1;
        }
        
        /* Status Messages */
        .status {
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
            display: none;
        }
        
        .status.success {
            background: var(--primary);
            color: var(--bg);
        }
        
        .status.error {
            background: var(--danger);
            color: white;
        }
        
        /* Context Helper */
        .context-box {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid var(--warning);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.85rem;
        }
        
        .context-box strong {
            color: var(--warning);
        }
        
        /* Loading */
        .processing {
            text-align: center;
            padding: 20px;
            display: none;
        }
        
        .processing .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            margin: 0 auto 10px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* iOS Optimizations */
        @supports (-webkit-touch-callout: none) {
            textarea, button {
                font-size: 16px !important;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>üöÄ Flow State Recovery</h1>
        <div class="mode-indicator" id="modeIndicator">SMART</div>
    </header>
    
    <div class="container">
        <!-- Compression Mode Selector -->
        <div class="mode-selector">
            <button class="mode-btn" onclick="setMode('full')">
                FULL
                <span class="percent">100%</span>
            </button>
            <button class="mode-btn active" onclick="setMode('smart')">
                SMART
                <span class="percent">70%</span>
            </button>
            <button class="mode-btn" onclick="setMode('tight')">
                TIGHT
                <span class="percent">40%</span>
            </button>
            <button class="mode-btn" onclick="setMode('ultra')">
                ULTRA
                <span class="percent">20%</span>
            </button>
        </div>
        
        <!-- Stats Bar -->
        <div class="stats-bar">
            <div class="stat">
                <div class="stat-value" id="inputSize">0KB</div>
                <div>Input</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="outputSize">0KB</div>
                <div>Output</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="savedPercent">0%</div>
                <div>Saved</div>
            </div>
        </div>
        
        <!-- Status Messages -->
        <div class="status" id="status"></div>
        
        <!-- Input Panel -->
        <div class="panel">
            <textarea id="inputArea" placeholder="Paste crashed chat here..."></textarea>
            <div class="action-bar">
                <button class="btn-secondary" onclick="pasteInput()">üìã Paste</button>
                <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear</button>
                <button class="btn-primary" onclick="recoverFlow()">‚ö° Recover</button>
            </div>
        </div>
        
        <!-- Processing Indicator -->
        <div class="processing" id="processing">
            <div class="spinner"></div>
            <div>Compressing for continuity...</div>
        </div>
        
        <!-- Context Helper -->
        <div class="context-box" id="contextBox" style="display: none;">
            <strong>‚ú® Ready to Continue!</strong><br>
            Copy the compressed output below and paste into a new chat to resume your flow state.
        </div>
        
        <!-- Output Panel -->
        <div class="panel" id="outputPanel" style="display: none;">
            <textarea id="outputArea" readonly placeholder="Compressed output..."></textarea>
            <div class="action-bar">
                <button class="btn-primary btn-full" onclick="copyAndContinue()">
                    üìã Copy & Continue Work
                </button>
            </div>
        </div>
    </div>
    
    <script>
        let currentMode = 'smart';
        let lastInput = '';
        
        // Compression configurations
        const compressionModes = {
            full: { name: 'FULL', ratio: 1.0, preserve: true },
            smart: { name: 'SMART', ratio: 0.7, preserve: true },
            tight: { name: 'TIGHT', ratio: 0.4, preserve: false },
            ultra: { name: 'ULTRA', ratio: 0.2, preserve: false }
        };
        
        // Set compression mode
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('modeIndicator').textContent = compressionModes[mode].name;
            
            // Re-process if we have input
            if (lastInput) {
                recoverFlow();
            }
        }
        
        // Update stats
        function updateStats() {
            const input = document.getElementById('inputArea').value;
            const output = document.getElementById('outputArea').value;
            
            const inputKb = (input.length / 1024).toFixed(1);
            const outputKb = (output.length / 1024).toFixed(1);
            const saved = input.length > 0 ? Math.round((1 - output.length / input.length) * 100) : 0;
            
            document.getElementById('inputSize').textContent = inputKb + 'KB';
            document.getElementById('outputSize').textContent = outputKb + 'KB';
            document.getElementById('savedPercent').textContent = saved + '%';
        }
        
        // Paste from clipboard
        async function pasteInput() {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('inputArea').value = text;
                updateStats();
            } catch (err) {
                document.getElementById('inputArea').focus();
                alert('Paste manually (Cmd+V)');
            }
        }
        
        // Clear all
        function clearAll() {
            document.getElementById('inputArea').value = '';
            document.getElementById('outputArea').value = '';
            document.getElementById('outputPanel').style.display = 'none';
            document.getElementById('contextBox').style.display = 'none';
            lastInput = '';
            updateStats();
        }
        
        // Main recovery function
        function recoverFlow() {
            const input = document.getElementById('inputArea').value;
            if (!input.trim()) {
                showStatus('Paste your crashed chat first!', 'error');
                return;
            }
            
            lastInput = input;
            document.getElementById('processing').style.display = 'block';
            
            setTimeout(() => {
                try {
                    const compressed = compressChat(input, currentMode);
                    
                    // Show output
                    document.getElementById('outputArea').value = compressed;
                    document.getElementById('outputPanel').style.display = 'block';
                    document.getElementById('contextBox').style.display = 'block';
                    document.getElementById('processing').style.display = 'none';
                    
                    updateStats();
                    showStatus('‚úÖ Compressed! Ready to continue your work.', 'success');
                    
                    // Auto-focus output for quick copy
                    document.getElementById('outputArea').focus();
                    
                } catch (error) {
                    document.getElementById('processing').style.display = 'none';
                    showStatus('Error compressing chat', 'error');
                }
            }, 300);
        }
        
        // Compression engine
        function compressChat(input, mode) {
            const config = compressionModes[mode];
            const messages = parseMessages(input);
            
            if (mode === 'full') {
                // Full format - just clean up
                return formatFull(messages);
            } else if (mode === 'smart') {
                // Smart compression - preserve context
                return formatSmart(messages);
            } else if (mode === 'tight') {
                // Tight - aggressive but readable
                return formatTight(messages);
            } else {
                // Ultra - maximum compression
                return formatUltra(messages);
            }
        }
        
        // Parse messages
        function parseMessages(text) {
            const messages = [];
            const lines = text.split('\n');
            let current = null;
            let inCode = false;
            
            for (const line of lines) {
                if (line.includes('```')) inCode = !inCode;
                
                if (!inCode && line.match(/^(Human:|You:|User:)/i)) {
                    if (current) messages.push(current);
                    current = {
                        role: 'H',
                        content: line.replace(/^(Human:|You:|User:)\s*/i, ''),
                        hasCode: false
                    };
                } else if (!inCode && line.match(/^(Assistant:|ChatGPT:|AI:)/i)) {
                    if (current) messages.push(current);
                    current = {
                        role: 'A',
                        content: line.replace(/^(Assistant:|ChatGPT:|AI:)\s*/i, ''),
                        hasCode: false
                    };
                } else if (current) {
                    current.content += '\n' + line;
                    if (line.includes('```') || line.includes('const ') || line.includes('function ')) {
                        current.hasCode = true;
                    }
                }
            }
            
            if (current) messages.push(current);
            
            // Fallback parsing
            if (messages.length === 0) {
                const chunks = text.split(/\n\n+/);
                chunks.forEach((chunk, i) => {
                    if (chunk.trim()) {
                        messages.push({
                            role: i % 2 === 0 ? 'H' : 'A',
                            content: chunk.trim(),
                            hasCode: chunk.includes('```') || chunk.includes('const ')
                        });
                    }
                });
            }
            
            return messages;
        }
        
        // Format: Full (clean but complete)
        function formatFull(messages) {
            let output = '=== RECOVERED CHAT ===\n\n';
            messages.forEach((msg, i) => {
                output += `${msg.role === 'H' ? 'Human' : 'Assistant'}: ${msg.content}\n\n`;
            });
            return output;
        }
        
        // Format: Smart (preserve code and context)
        function formatSmart(messages) {
            let output = '=== CONTEXT RECOVERY ===\n';
            let lastRole = '';
            
            messages.forEach((msg, i) => {
                // Detect section changes
                if (msg.hasCode && lastRole !== 'code') {
                    output += '\n[CODE SECTION]\n';
                    lastRole = 'code';
                } else if (!msg.hasCode && lastRole === 'code') {
                    output += '\n[DISCUSSION]\n';
                    lastRole = 'discussion';
                }
                
                // Compress content smartly
                const content = msg.hasCode ? 
                    msg.content : // Preserve code exactly
                    msg.content
                        .replace(/\n\n+/g, '\n') // Remove extra lines
                        .replace(/\s+/g, ' ') // Normalize spaces
                        .trim();
                
                output += `${msg.role}: ${content}\n`;
            });
            
            return output;
        }
        
        // Format: Tight (aggressive compression)
        function formatTight(messages) {
            let output = 'RECOVERY:\n';
            
            messages.forEach((msg, i) => {
                let content = msg.content
                    .replace(/\n+/g, ' ')
                    .replace(/\s+/g, ' ')
                    .substring(0, 200); // Limit length
                
                if (msg.content.length > 200) content += '...';
                
                output += `${msg.role}:${content}\n`;
            });
            
            return output;
        }
        
        // Format: Ultra (maximum compression)
        function formatUltra(messages) {
            // Extract only the most important parts
            const key = messages.map((msg, i) => {
                const words = msg.content.split(/\s+/);
                const important = words.filter(w => 
                    w.length > 4 || 
                    w.includes('error') || 
                    w.includes('fix') ||
                    w.includes('const') ||
                    /^[A-Z]/.test(w)
                ).slice(0, 10).join(' ');
                
                return `${msg.role}:${important}`;
            }).join('|');
            
            return `ULTRA:${key}\nMSGS:${messages.length}`;
        }
        
        // Copy and continue
        async function copyAndContinue() {
            const output = document.getElementById('outputArea');
            output.select();
            output.setSelectionRange(0, 999999);
            
            try {
                await navigator.clipboard.writeText(output.value);
                
                // Visual feedback
                const btn = event.target;
                btn.textContent = '‚úÖ Copied! Continue your work!';
                btn.style.background = 'var(--primary)';
                
                setTimeout(() => {
                    btn.textContent = 'üìã Copy & Continue Work';
                }, 3000);
                
            } catch (err) {
                document.execCommand('copy');
                alert('Copied! Paste into new chat to continue.');
            }
        }
        
        // Show status message
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }
        
        // Auto-update stats on input
        document.getElementById('inputArea').addEventListener('input', () => {
            const input = document.getElementById('inputArea').value;
            const inputKb = (input.length / 1024).toFixed(1);
            document.getElementById('inputSize').textContent = inputKb + 'KB';
        });
    </script>
</body>
</html>
