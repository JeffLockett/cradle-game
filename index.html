// PIN input keyboard support
            if (document.getElementById('devLoginModal').style.display === 'block') {
                const input = document.getElementById('pinInput');
                if (e.key >= '0' && e.key <= '9' && input.value.length < 4) {
                    addPin(e.key);
                } else if (e.key === 'Enter') {
                    submitPin();
                } else if (e.key === 'Backspace') {
                    clearPin();
                } else if (e.key === 'Escape') {
                    hideDevLogin();
                }
                e.preventDefault();
                return;
            }<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cradle Adventure: Sacred Valley - Dev Master Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            border: 3px solid #333;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            width: 100%;
            height: 100vh;
            max-width: 100%;
            max-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* DEV TRACKER INTEGRATION */
        #devTracker {
            position: fixed;
            top: 0;
            left: -400px;
            width: 400px;
            height: 100vh;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0f1f 100%);
            border-right: 3px solid #00ff88;
            transition: left 0.3s ease;
            z-index: 2000;
            overflow-y: auto;
            color: white;
            font-size: 12px;
        }

        #devTracker.open {
            left: 0;
        }

        #trackerToggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 255, 136, 0.9);
            color: black;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            z-index: 2001;
            transition: all 0.3s ease;
        }

        #trackerToggle:hover {
            background: #00ccff;
            transform: scale(1.05);
        }

        #trackerToggle.active {
            left: 420px;
            background: #ff4444;
            color: white;
        }

        .tracker-header {
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.5);
        }

        .tracker-title {
            font-size: 18px;
            color: #00ff88;
            margin-bottom: 10px;
        }

        .dev-advancement-display {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 204, 255, 0.2));
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }

        .dev-rank {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 5px;
        }

        .dev-path {
            font-size: 14px;
            color: #00ccff;
            font-style: italic;
        }

        .xp-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #666;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }

        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff, #00ff88);
            background-size: 200% 100%;
            animation: shimmer 3s infinite;
            transition: width 0.5s ease;
        }

        @keyframes shimmer {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        .dev-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #00ff88;
        }

        .stat-label {
            font-size: 10px;
            color: #999;
            text-transform: uppercase;
        }

        .quest-section {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .quest-title {
            color: #00ff88;
            font-weight: bold;
            font-size: 14px;
        }

        .quest-reward {
            color: #ffd700;
            font-size: 11px;
        }

        .quest-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .quest-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            transition: width 0.5s ease;
        }

        .quest-objectives {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .quest-objective {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }

        .quest-checkbox {
            width: 12px;
            height: 12px;
            border: 1px solid #00ff88;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            transition: all 0.3s ease;
        }

        .quest-checkbox.completed {
            background: #00ff88;
            color: black;
            animation: questComplete 0.5s ease;
        }

        @keyframes questComplete {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .quest-checkbox.completed::after {
            content: '✓';
        }

        .dev-techniques {
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
        }

        .technique-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .technique-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .technique-card:hover {
            border-color: #00ff88;
            transform: translateY(-2px);
        }

        .technique-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .technique-icon {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .technique-name {
            font-size: 10px;
            color: #00ccff;
        }

        .technique-level {
            font-size: 9px;
            color: #666;
        }

        .live-feed {
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
        }

        .feed-title {
            color: #00ccff;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .feed-live-indicator {
            width: 6px;
            height: 6px;
            background: #00ff88;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }

        .feed-item {
            padding: 8px;
            margin: 5px 0;
            border-left: 3px solid transparent;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 0 3px 3px 0;
            font-size: 11px;
            transition: all 0.3s ease;
            animation: feedItemSlide 0.5s ease;
        }

        @keyframes feedItemSlide {
            from { 
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .feed-commit {
            border-left-color: #00ff88;
        }

        .feed-issue {
            border-left-color: #ff4444;
        }

        .feed-achievement {
            border-left-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            font-weight: bold;
        }

        .feed-merge {
            border-left-color: #00ccff;
        }

        .github-sync {
            padding: 15px;
            border-top: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
        }

        .sync-button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .sync-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
        }

        .sync-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .repo-input {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #666;
            border-radius: 3px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            margin-bottom: 10px;
        }

        .sync-status {
            font-size: 10px;
            opacity: 0.8;
            text-align: center;
        }

        /* GAME UI STYLES */
        #ui {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            font-size: 14px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .healthBar {
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid #fff;
            margin: 5px 0;
            position: relative;
        }

        .healthFill {
            height: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }

        .madraBar {
            width: 200px;
            height: 15px;
            background-color: #222;
            border: 2px solid #66f;
            margin: 5px 0;
            position: relative;
        }

        .madraFill {
            height: 100%;
            background: linear-gradient(90deg, #0066ff, #00ccff);
            transition: width 0.3s;
        }

        #combatUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: white;
            display: none;
            pointer-events: none;
        }

        .combatBars {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .fighterInfo {
            text-align: center;
        }

        .comboCounter {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #ff0;
            text-shadow: 3px 3px 0px #f00;
            display: none;
        }

        #dialogue {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ff88;
            border-radius: 10px;
            padding: 15px 25px;
            color: white;
            max-width: 80%;
            display: none;
            text-align: center;
            font-size: 16px;
            z-index: 500;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .floatingText {
            position: absolute;
            color: #ff0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0px black;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            to {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        .screenFlash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            opacity: 0;
            pointer-events: none;
        }

        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            top: 0;
            pointer-events: none;
            display: none;
        }
        
        .touch-zone {
            position: absolute;
            pointer-events: auto;
            opacity: 0.3;
            transition: opacity 0.2s;
        }
        
        .touch-zone:active {
            opacity: 0.6;
        }
        
        #virtualJoystick {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
        }
        
        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
            pointer-events: none;
        }
        
        .action-button {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 1px 1px 0 black;
        }
        
        #actionA {
            bottom: 100px;
            right: 140px;
        }
        
        #actionB {
            bottom: 50px;
            right: 80px;
        }
        
        #actionSpecial {
            bottom: 150px;
            right: 80px;
            background: rgba(0, 100, 255, 0.3);
        }
        
        #combatMoveLeft {
            bottom: 50px;
            left: 50px;
            width: 80px;
            height: 80px;
        }
        
        #combatMoveRight {
            bottom: 50px;
            left: 150px;
            width: 80px;
            height: 80px;
        }
        
        .mobile-instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            text-shadow: 2px 2px 0 black;
            pointer-events: none;
        }

        #advancementNotice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0;
            font-size: 36px;
            text-shadow: 3px 3px 0px #f00;
            display: none;
            text-align: center;
            animation: advancePulse 1s ease-in-out infinite;
        }

        @keyframes advancePulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 10px;
            color: white;
            font-size: 12px;
            max-width: 200px;
        }

        .control-line {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .key {
            color: #00ff88;
            font-weight: bold;
        }

        .help-reminder {
            text-align: center;
            margin-top: 5px;
            font-style: italic;
            opacity: 0.7;
        }

        #fullscreenBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            color: #00ff88;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        #controlsToggle {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            color: #00ff88;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .controls-hint {
            position: absolute;
            bottom: 50px;
            left: 10px;
            color: #00ff88;
            font-size: 14px;
            animation: pulse 2s infinite;
        }

        #fullControls {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ff88;
            border-radius: 15px;
            padding: 30px;
            color: white;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .close-controls {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #ff0000;
        }

        .control-section {
            margin: 20px 0;
        }

        .control-section h3 {
            color: #00ff88;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 5px;
            margin-bottom: 15px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
        }

        .control-key {
            background: rgba(0, 255, 136, 0.2);
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
            color: #00ff88;
        }

        #saveMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #fff;
            padding: 20px;
            color: white;
            text-align: center;
            z-index: 100;
            display: none;
        }

        /* Dev Achievement Popup */
        .dev-achievement-popup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            color: white;
            transform: translateX(400px);
            transition: transform 0.5s ease;
            z-index: 1500;
            max-width: 300px;
            font-size: 12px;
        }

        .dev-achievement-popup.show {
            transform: translateX(0);
        }

        .xp-gain-effect {
            position: fixed;
            top: 50%;
            left: 200px;
            color: #ffd700;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: xpBurst 2s ease-out forwards;
            z-index: 1600;
        }

        @keyframes xpBurst {
            0% {
                opacity: 1;
                transform: scale(0.5) translateY(0);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) translateY(-20px);
            }
            100% {
                opacity: 0;
                transform: scale(1) translateY(-40px);
            }
        }

        #devModeButton {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: #666;
            border: 1px solid #333;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            z-index: 2001;
            transition: all 0.3s ease;
        }

        #devModeButton:hover {
            color: #999;
            border-color: #666;
        }

        #devLoginModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 30px;
            z-index: 3000;
            display: none;
            text-align: center;
            color: white;
            min-width: 300px;
        }

        #devLoginModal h3 {
            color: #00ff88;
            margin-bottom: 20px;
        }

        #pinInput {
            width: 200px;
            padding: 10px;
            font-size: 24px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 5px;
            color: white;
            font-family: 'Courier New', monospace;
            letter-spacing: 10px;
            margin-bottom: 20px;
        }

        #pinInput:focus {
            outline: none;
            border-color: #00ff88;
        }

        .pin-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-width: 240px;
            margin: 0 auto 20px;
        }

        .pin-button {
            padding: 20px;
            font-size: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #666;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s ease;
            font-family: 'Courier New', monospace;
        }

        .pin-button:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            transform: scale(1.05);
        }

        .pin-button:active {
            transform: scale(0.95);
        }

        .pin-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .pin-submit, .pin-cancel {
            padding: 10px 20px;
            background: #00ff88;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .pin-cancel {
            background: #ff4444;
            color: white;
        }

        .pin-submit:hover {
            background: #00ccff;
        }

        .pin-cancel:hover {
            background: #ff6666;
        }

        #devModeStatus {
            position: fixed;
            top: 60px;
            left: 20px;
            color: #00ff88;
            font-size: 12px;
            display: none;
            z-index: 2000;
        }

        /* Enhanced mobile styles for iPhone */
        @media (max-width: 768px) and (-webkit-min-device-pixel-ratio: 2) {
            /* Prevent iOS zoom on input focus */
            input[type="text"], input[type="password"], input[type="number"] {
                font-size: 16px !important;
            }
            
            #gameCanvas {
                touch-action: none;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
            }
            
            #mobileControls {
                pointer-events: none;
            }
            
            .touch-zone {
                pointer-events: auto;
                -webkit-tap-highlight-color: transparent;
            }
            
            #virtualJoystick {
                position: fixed;
                bottom: 60px;
                left: 40px;
                width: 140px;
                height: 140px;
            }
            
            .action-button {
                position: fixed;
                width: 70px;
                height: 70px;
                font-size: 14px;
            }
            
            #actionA {
                bottom: 120px;
                right: 160px;
            }
            
            #actionB {
                bottom: 60px;
                right: 90px;
            }
            
            #actionSpecial {
                bottom: 180px;
                right: 90px;
            }
            
            #combatMoveLeft {
                bottom: 60px;
                left: 40px;
                width: 90px;
                height: 90px;
            }
            
            #combatMoveRight {
                bottom: 60px;
                left: 150px;
                width: 90px;
                height: 90px;
            }
            
            #devLoginModal {
                width: 90%;
                max-width: 350px;
            }
            
            .pin-button {
                padding: 25px;
                font-size: 24px;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            body {
                -webkit-text-size-adjust: 100%;
            }
            
            #gameContainer {
                -webkit-overflow-scrolling: touch;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Dev Tracker Toggle Button (Hidden until authenticated) -->
        <button id="trackerToggle" onclick="toggleDevTracker()" style="display: none;">📊 Dev Path</button>
        
        <!-- Dev Mode Unlock Button -->
        <button id="devModeButton" onclick="showDevLogin()">🔒</button>
        
        <!-- Integrated Dev Tracker Panel -->
        <div id="devTracker">
            <div class="tracker-header">
                <div class="tracker-title">Sacred Artist Developer Journey</div>
                <div class="dev-advancement-display">
                    <div class="dev-rank" id="devRank">Iron Body</div>
                    <div class="dev-path" id="devPath">Path of the Script Lord</div>
                    <div class="xp-bar">
                        <div class="xp-fill" id="devXPFill" style="width: 65%;"></div>
                        <div class="xp-text"><span id="devXP">650</span> / <span id="devMaxXP">1000</span> XP</div>
                    </div>
                </div>
            </div>

            <div class="dev-stats">
                <div class="stat-card">
                    <div class="stat-value" id="totalCommits">247</div>
                    <div class="stat-label">Commits</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="devStreak">12</div>
                    <div class="stat-label">Day Streak</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="bugsFoxed">34</div>
                    <div class="stat-label">Bugs Fixed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="featuresShipped">8</div>
                    <div class="stat-label">Features</div>
                </div>
            </div>

            <div class="quest-section">
                <div class="quest-header">
                    <div class="quest-title">🎯 Mobile Combat Perfection</div>
                    <div class="quest-reward">+200 XP</div>
                </div>
                <div class="quest-progress">
                    <div class="quest-progress-fill" id="currentQuestProgress" style="width: 40%;"></div>
                </div>
                <ul class="quest-objectives">
                    <li class="quest-objective">
                        <div class="quest-checkbox completed"></div>
                        <span>Fix joystick drift on touch release</span>
                    </li>
                    <li class="quest-objective">
                        <div class="quest-checkbox completed"></div>
                        <span>Add smooth knob return animation</span>
                    </li>
                    <li class="quest-objective">
                        <div class="quest-checkbox"></div>
                        <span>Implement haptic feedback for attacks</span>
                    </li>
                    <li class="quest-objective">
                        <div class="quest-checkbox"></div>
                        <span>Add gesture-based special moves</span>
                    </li>
                    <li class="quest-objective">
                        <div class="quest-checkbox"></div>
                        <span>Test on 5 different mobile devices</span>
                    </li>
                </ul>
            </div>

            <div class="dev-techniques">
                <div class="feed-title">Developer Techniques</div>
                <div class="technique-grid">
                    <div class="technique-card">
                        <div class="technique-icon">🔧</div>
                        <div class="technique-name">Refactor Palm</div>
                        <div class="technique-level">Level 3</div>
                    </div>
                    <div class="technique-card">
                        <div class="technique-icon">🐛</div>
                        <div class="technique-name">Bug Crusher</div>
                        <div class="technique-level">Level 5</div>
                    </div>
                    <div class="technique-card">
                        <div class="technique-icon">🚀</div>
                        <div class="technique-name">Deploy Strike</div>
                        <div class="technique-level">Level 2</div>
                    </div>
                    <div class="technique-card locked">
                        <div class="technique-icon">🔥</div>
                        <div class="technique-name">Blackflame Optimization</div>
                        <div class="technique-level">Locked</div>
                    </div>
                </div>
            </div>

            <div class="live-feed">
                <div class="feed-title">
                    <div class="feed-live-indicator"></div>
                    Repository Activity Feed
                </div>
                <div id="devFeed">
                    <div class="feed-item feed-achievement">🏆 Achievement: Mobile Master - First responsive design!</div>
                    <div class="feed-item feed-commit">✅ fix: Resolved joystick drift issue - +50 XP</div>
                    <div class="feed-item feed-commit">✅ feat: Added smooth knob animations - +75 XP</div>
                    <div class="feed-item feed-merge">🔀 Merged PR #42: Mobile controls overhaul</div>
                    <div class="feed-item feed-issue">🐛 Issue #43: Investigate combat button lag</div>
                </div>
            </div>

            <div class="github-sync">
                <input type="text" id="repoInput" class="repo-input" placeholder="username/repository-name" value="">
                <button class="sync-button" onclick="connectToGitHub()" id="syncButton">🔗 Connect Sacred Repository</button>
                <button class="sync-button" onclick="syncNow()" id="manualSync" disabled>🔄 Force Madra Sync</button>
                <div class="sync-status" id="syncStatus">Repository disconnected</div>
            </div>
        </div>
        
        <!-- Game UI -->
        <button id="fullscreenBtn" onclick="toggleFullscreen()">⛶ Fullscreen</button>
        
        <div id="ui">
            <div>Wei Shi Lindon - <span id="advancement">Unsouled</span></div>
            <div class="healthBar">
                <div class="healthFill" id="playerHealth" style="width: 100%"></div>
            </div>
            <div class="madraBar">
                <div class="madraFill" id="playerMadra" style="width: 100%"></div>
            </div>
            <div>Madra Collected: <span id="madraCount">0</span></div>
            <div>Combat Wins: <span id="winCount">0</span></div>
        </div>

        <div id="combatUI">
            <div class="combatBars">
                <div class="fighterInfo">
                    <h3>LINDON</h3>
                    <div class="healthBar" style="width: 300px">
                        <div class="healthFill" id="combatPlayerHealth" style="width: 100%"></div>
                    </div>
                    <div class="madraBar" style="width: 300px">
                        <div class="madraFill" id="combatPlayerMadra" style="width: 100%"></div>
                    </div>
                </div>
                <div class="fighterInfo">
                    <h3 id="enemyName">ENEMY</h3>
                    <div class="healthBar" style="width: 300px">
                        <div class="healthFill" id="combatEnemyHealth" style="width: 100%; background-color: #f00"></div>
                    </div>
                </div>
            </div>
            <div class="comboCounter" id="comboCounter">COMBO x<span id="comboCount">0</span></div>
        </div>

        <div id="dialogue"></div>
        <div class="screenFlash" id="screenFlash"></div>
        <div id="advancementNotice"></div>

        <div id="instructions">
            <div id="explorationInstructions">
                <div class="control-line">
                    <span>Move:</span>
                    <span class="key">WASD/Arrows</span>
                </div>
                <div class="control-line">
                    <span>Interact:</span>
                    <span class="key">SPACE</span>
                </div>
                <div class="control-line">
                    <span>Dev Panel:</span>
                    <span class="key">T</span>
                </div>
                <div class="control-line">
                    <span>Save:</span>
                    <span class="key">F5</span>
                </div>
                <div class="control-line">
                    <span>Load:</span>
                    <span class="key">F9</span>
                </div>
                <div class="help-reminder">Press ? for Full Help</div>
            </div>
            <div id="combatInstructions" style="display: none">
                <div class="control-line">
                    <span>Move:</span>
                    <span class="key">A/D</span>
                </div>
                <div class="control-line">
                    <span>Punch:</span>
                    <span class="key">J</span>
                </div>
                <div class="control-line">
                    <span>Kick:</span>
                    <span class="key">K</span>
                </div>
                <div class="control-line">
                    <span>Block:</span>
                    <span class="key">L (Hold)</span>
                </div>
                <div class="control-line">
                    <span>Empty Palm:</span>
                    <span class="key">SPACE</span>
                </div>
                <div class="help-reminder">Press ? for Full Help</div>
            </div>
        </div>
        
        <button id="controlsToggle" onclick="toggleControls()">Controls (C)</button>
        
        <div class="controls-hint" id="controlsHint">
            Press C for Controls | T for Dev Tracker
        </div>
        
        <div id="fullControls">
            <span class="close-controls" onclick="hideControls()">×</span>
            <h2>Sacred Artist Control Manual</h2>
            
            <div class="control-section">
                <h3>🎮 Basic Movement</h3>
                <div class="control-item">
                    <span>Move</span>
                    <span class="control-key">WASD / Arrow Keys</span>
                </div>
                <div class="control-item">
                    <span>Interact/Talk</span>
                    <span class="control-key">SPACE</span>
                </div>
                <div class="control-item">
                    <span>Run (with certain paths)</span>
                    <span class="control-key">SHIFT</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>⚔️ Combat Controls</h3>
                <div class="control-item">
                    <span>Move Left/Right</span>
                    <span class="control-key">A / D</span>
                </div>
                <div class="control-item">
                    <span>Punch</span>
                    <span class="control-key">J</span>
                </div>
                <div class="control-item">
                    <span>Kick</span>
                    <span class="control-key">K</span>
                </div>
                <div class="control-item">
                    <span>Block</span>
                    <span class="control-key">L (Hold)</span>
                </div>
                <div class="control-item">
                    <span>Empty Palm (Uses Madra)</span>
                    <span class="control-key">SPACE</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>💾 System Controls</h3>
                <div class="control-item">
                    <span>Quick Save</span>
                    <span class="control-key">F5</span>
                </div>
                <div class="control-item">
                    <span>Quick Load</span>
                    <span class="control-key">F9</span>
                </div>
                <div class="control-item">
                    <span>Save Menu</span>
                    <span class="control-key">M</span>
                </div>
                <div class="control-item">
                    <span>Dev Tracker</span>
                    <span class="control-key">T</span>
                </div>
                <div class="control-item">
                    <span>Toggle Controls</span>
                    <span class="control-key">C</span>
                </div>
                <div class="control-item">
                    <span>Close Menus</span>
                    <span class="control-key">ESC</span>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px; color: #00ff88;">
                <em>"The dragon advances through understanding and debugging."</em>
            </div>
        </div>
        
        <div id="mobileControls">
            <div id="explorationControls">
                <div id="virtualJoystick" class="touch-zone">
                    <div id="joystickKnob"></div>
                </div>
                <div id="actionA" class="action-button touch-zone">Talk</div>
                <div class="mobile-instructions">Move: Left side | Interact: Right side</div>
            </div>
            
            <div id="combatControls" style="display: none;">
                <div id="combatMoveLeft" class="action-button touch-zone">←</div>
                <div id="combatMoveRight" class="action-button touch-zone">→</div>
                <div id="actionB" class="action-button touch-zone">Punch</div>
                <div id="actionA" class="action-button touch-zone">Kick</div>
                <div id="actionSpecial" class="action-button touch-zone">Palm</div>
                <div class="mobile-instructions">Tap buttons to fight!</div>
            </div>
        </div>
        
        <div id="saveMenu">
            <h2 style="margin-top: 0;">SAVE MENU</h2>
            <div id="saveSlots" style="margin: 20px 0;"></div>
            <div style="margin-top: 20px;">
                <button onclick="closeSaveMenu()" style="padding: 10px 20px; font-size: 16px; cursor: pointer;">Close (ESC)</button>
            </div>
        </div>
    </div>

    <!-- Dev Login Modal -->
    <div id="devLoginModal">
        <h3>Developer Mode Access</h3>
        <p style="color: #999; margin-bottom: 20px;">Enter 4-digit PIN</p>
        <input type="password" id="pinInput" maxlength="4" pattern="[0-9]*" inputmode="numeric" autocomplete="off">
        <div class="pin-buttons">
            <button class="pin-button" onclick="addPin('1')">1</button>
            <button class="pin-button" onclick="addPin('2')">2</button>
            <button class="pin-button" onclick="addPin('3')">3</button>
            <button class="pin-button" onclick="addPin('4')">4</button>
            <button class="pin-button" onclick="addPin('5')">5</button>
            <button class="pin-button" onclick="addPin('6')">6</button>
            <button class="pin-button" onclick="addPin('7')">7</button>
            <button class="pin-button" onclick="addPin('8')">8</button>
            <button class="pin-button" onclick="addPin('9')">9</button>
            <button class="pin-button" onclick="clearPin()" style="grid-column: 1;">⌫</button>
            <button class="pin-button" onclick="addPin('0')">0</button>
            <button class="pin-button" onclick="submitPin()" style="grid-column: 3;">✓</button>
        </div>
        <div class="pin-controls">
            <button class="pin-cancel" onclick="hideDevLogin()">Cancel</button>
        </div>
        <p id="pinError" style="color: #ff4444; margin-top: 10px; display: none;">Incorrect PIN</p>
    </div>

    <div id="devModeStatus">🔓 Dev Mode Active</div>

    <!-- Dev Achievement Popup -->
    <div class="dev-achievement-popup" id="devAchievementPopup">
        <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">🏆 Development Achievement!</div>
        <div id="devAchievementText">New milestone reached!</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // DEV TRACKER INTEGRATION WITH SECURITY
        let devModeUnlocked = false;
        const DEV_PIN = '1337'; // Change this to your preferred PIN
        
        // Dev mode security functions
        function showDevLogin() {
            document.getElementById('devLoginModal').style.display = 'block';
            document.getElementById('pinInput').value = '';
            document.getElementById('pinInput').focus();
            document.getElementById('pinError').style.display = 'none';
            game.paused = true;
        }
        
        function hideDevLogin() {
            document.getElementById('devLoginModal').style.display = 'none';
            document.getElementById('pinInput').value = '';
            game.paused = false;
        }
        
        function addPin(digit) {
            const input = document.getElementById('pinInput');
            if (input.value.length < 4) {
                input.value += digit;
                if (input.value.length === 4) {
                    setTimeout(submitPin, 200);
                }
            }
        }
        
        function clearPin() {
            document.getElementById('pinInput').value = '';
        }
        
        function submitPin() {
            const input = document.getElementById('pinInput');
            const enteredPin = input.value;
            
            if (enteredPin === DEV_PIN) {
                devModeUnlocked = true;
                hideDevLogin();
                enableDevMode();
                
                // Store dev mode state in memory
                memorySaves['devModeUnlocked'] = 'true';
                
                // Show success notification
                devTracker.showDevAchievement('Developer Mode Unlocked!', 'Full access granted');
            } else {
                document.getElementById('pinError').style.display = 'block';
                input.value = '';
                
                // Shake the modal
                const modal = document.getElementById('devLoginModal');
                modal.style.animation = 'shake 0.5s';
                setTimeout(() => {
                    modal.style.animation = '';
                }, 500);
            }
        }
        
        function enableDevMode() {
            document.getElementById('trackerToggle').style.display = 'block';
            document.getElementById('devModeButton').textContent = '🔓';
            document.getElementById('devModeButton').style.color = '#00ff88';
            document.getElementById('devModeStatus').style.display = 'block';
            
            // Auto-hide status after 3 seconds
            setTimeout(() => {
                document.getElementById('devModeStatus').style.display = 'none';
            }, 3000);
        }
        
        function checkDevModeStatus() {
            // Check if dev mode was previously unlocked
            if (memorySaves['devModeUnlocked'] === 'true') {
                devModeUnlocked = true;
                enableDevMode();
            }
        }
        
        // Add shake animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes shake {
                0%, 100% { transform: translate(-50%, -50%) translateX(0); }
                25% { transform: translate(-50%, -50%) translateX(-10px); }
                75% { transform: translate(-50%, -50%) translateX(10px); }
            }
        `;
        document.head.appendChild(style);
        
        // Enhanced iPhone touch handling
        function setupiOSFixes() {
            // Prevent iOS bounce scrolling
            document.addEventListener('touchmove', function(e) {
                if (e.target.closest('#gameContainer')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Fix viewport for iOS
            const viewport = document.querySelector('meta[name=viewport]');
            if (viewport) {
                viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
            }
            
            // Prevent double-tap zoom
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(e) {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }
        
        // Call iOS fixes if on iPhone
        if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
            setupiOSFixes();
        }
        class DevTracker {
            constructor() {
                this.isOpen = false;
                this.githubConnected = false;
                this.repoData = null;
                this.syncInterval = null;
                
                // Developer progression data
                this.devData = {
                    advancement: 'Iron',
                    path: 'Path of the Script Lord',
                    xp: 650,
                    maxXP: 1000,
                    totalCommits: 247,
                    streak: 12,
                    bugsFoxed: 34,
                    featuresShipped: 8,
                    techniques: {
                        refactorPalm: 3,
                        bugCrusher: 5,
                        deployStrike: 2,
                        blackflameOptimization: 0
                    }
                };
                
                this.questData = {
                    current: 'Mobile Combat Perfection',
                    objectives: [
                        { text: 'Fix joystick drift on touch release', completed: true },
                        { text: 'Add smooth knob return animation', completed: true },
                        { text: 'Implement haptic feedback for attacks', completed: false },
                        { text: 'Add gesture-based special moves', completed: false },
                        { text: 'Test on 5 different mobile devices', completed: false }
                    ],
                    xpReward: 200
                };
                
                this.devAdvancements = [
                    { name: 'Copper', xp: 100, title: 'Apprentice Coder' },
                    { name: 'Iron', xp: 500, title: 'Script Lord' },
                    { name: 'Jade', xp: 1500, title: 'Bug Sage' },
                    { name: 'Gold', xp: 3000, title: 'Deploy Master' },
                    { name: 'Underlord', xp: 6000, title: 'Code Underlord' },
                    { name: 'Overlord', xp: 12000, title: 'Architecture Overlord' },
                    { name: 'Archlord', xp: 25000, title: 'System Archlord' },
                    { name: 'Sage', xp: 50000, title: 'Code Sage' },
                    { name: 'Herald', xp: 100000, title: 'Bug Herald' },
                    { name: 'Monarch', xp: 200000, title: 'Tech Monarch' }
                ];
                
                this.initializeTracker();
            }

            initializeTracker() {
                this.loadDevProgress();
                this.startPeriodicSync();
                this.setupEventListeners();
                this.updateUI();
            }

            loadDevProgress() {
                try {
                    if (saveMethod === 'localStorage') {
                        const saved = localStorage.getItem('devProgress');
                        if (saved) {
                            const data = JSON.parse(saved);
                            Object.assign(this.devData, data.devData || {});
                            Object.assign(this.questData, data.questData || {});
                        }
                    } else {
                        // Use memory storage fallback
                        const saved = memorySaves['devProgress'];
                        if (saved) {
                            const data = JSON.parse(saved);
                            Object.assign(this.devData, data.devData || {});
                            Object.assign(this.questData, data.questData || {});
                        }
                    }
                } catch (e) {
                    console.log('Could not load dev progress:', e.message);
                }
            }

            saveDevProgress() {
                try {
                    const data = JSON.stringify({
                        devData: this.devData,
                        questData: this.questData
                    });
                    
                    if (saveMethod === 'localStorage') {
                        localStorage.setItem('devProgress', data);
                    } else {
                        memorySaves['devProgress'] = data;
                    }
                } catch (e) {
                    console.log('Could not save dev progress:', e.message);
                }
            }

            setupEventListeners() {
                // Listen for game events
                document.addEventListener('gameProgress', (e) => {
                    this.handleGameProgress(e.detail);
                });
                
                // Listen for specific game milestones
                document.addEventListener('playerAdvancement', (e) => {
                    this.gainXP(100, `Player reached ${e.detail.level}!`);
                });
                
                document.addEventListener('combatVictory', (e) => {
                    this.devData.bugsFoxed++;
                    this.gainXP(25, 'Combat system test complete!');
                });
                
                document.addEventListener('madraCollected', (e) => {
                    if (e.detail.total >= 100 && e.detail.total < 110) {
                        this.gainXP(50, 'First 100 madra milestone!');
                    }
                });
            }

            toggle() {
                this.isOpen = !this.isOpen;
                const tracker = document.getElementById('devTracker');
                const toggle = document.getElementById('trackerToggle');
                
                if (this.isOpen) {
                    tracker.classList.add('open');
                    toggle.classList.add('active');
                    toggle.textContent = '✕ Close';
                } else {
                    tracker.classList.remove('open');
                    toggle.classList.remove('active');
                    toggle.textContent = '📊 Dev Path';
                }
            }

            async connectToGitHub() {
                const repoInput = document.getElementById('repoInput').value.trim();
                if (!repoInput || !repoInput.includes('/')) {
                    this.updateSyncStatus('Invalid repository format', 'error');
                    return;
                }

                this.updateSyncStatus('Channeling GitHub madra...', 'connecting');
                
                try {
                    const [owner, repo] = repoInput.split('/');
                    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}`);
                    
                    if (response.ok) {
                        this.repoData = await response.json();
                        this.githubConnected = true;
                        this.updateSyncStatus('Sacred repository connected!', 'success');
                        
                        document.getElementById('manualSync').disabled = false;
                        await this.syncRepositoryData();
                        
                        this.showDevAchievement('Repository Bonded!', 'GitHub integration successful');
                        this.gainXP(100, 'Connected to sacred repository');
                        
                    } else if (response.status === 404) {
                        this.updateSyncStatus('Repository hidden in shadow', 'error');
                    } else {
                        this.updateSyncStatus('Connection severed - check your path', 'error');
                    }
                } catch (error) {
                    console.error('GitHub connection error:', error);
                    this.updateSyncStatus('Madra network disrupted', 'error');
                }
            }

            async syncRepositoryData() {
                if (!this.githubConnected || !this.repoData) return;

                try {
                    const [owner, repo] = [this.repoData.owner.login, this.repoData.name];
                    
                    // Fetch recent commits
                    const commitsResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/commits?per_page=10`);
                    const commits = commitsResponse.ok ? await commitsResponse.json() : [];
                    
                    // Fetch issues
                    const issuesResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/issues?state=open&per_page=5`);
                    const issues = issuesResponse.ok ? await issuesResponse.json() : [];
                    
                    // Analyze and update
                    this.analyzeCommits(commits);
                    this.updateLiveFeed(commits, issues);
                    
                } catch (error) {
                    console.error('Sync error:', error);
                    this.updateSyncStatus('Sync disrupted - retrying...', 'error');
                }
            }

            analyzeCommits(commits) {
                commits.forEach(commit => {
                    const message = commit.commit.message.toLowerCase();
                    const xp = this.calculateCommitXP(message);
                    
                    // Check for quest progress
                    if (message.includes('mobile') || message.includes('touch') || message.includes('joystick')) {
                        this.updateQuestProgress();
                    }
                    
                    // Award XP for new commits (simplified - in real app would track seen commits)
                    if (Math.random() > 0.7) {
                        this.gainXP(xp, `Commit: ${commit.commit.message.split('\n')[0]}`);
                    }
                });
            }

            calculateCommitXP(commitMessage) {
                const message = commitMessage.toLowerCase();
                if (message.includes('feat:') || message.includes('feature:')) return 75;
                if (message.includes('fix:') || message.includes('bug:')) return 50;
                if (message.includes('refactor:')) return 40;
                if (message.includes('perf:')) return 60;
                if (message.includes('test:')) return 35;
                if (message.includes('docs:')) return 25;
                return 30;
            }

            updateLiveFeed(commits, issues) {
                const feed = document.getElementById('devFeed');
                const feedItems = [];
                
                // Recent achievements
                if (this.devData.xp > 500 && this.devData.xp < 550) {
                    feedItems.push('<div class="feed-item feed-achievement">🏆 Achievement: Mobile Master - First responsive design!</div>');
                }
                
                // Recent commits
                commits.slice(0, 4).forEach(commit => {
                    const message = commit.commit.message.split('\n')[0];
                    const xp = this.calculateCommitXP(message);
                    feedItems.push(`<div class="feed-item feed-commit">✅ ${message} - +${xp} XP</div>`);
                });
                
                // Recent issues
                issues.slice(0, 2).forEach(issue => {
                    feedItems.push(`<div class="feed-item feed-issue">🐛 Issue #${issue.number}: ${issue.title}</div>`);
                });
                
                feed.innerHTML = feedItems.join('');
            }

            updateQuestProgress(forceComplete = false) {
                const incomplete = this.questData.objectives.filter(o => !o.completed);
                if (incomplete.length > 0 && (Math.random() > 0.7 || forceComplete)) {
                    incomplete[0].completed = true;
                    this.updateQuestUI();
                    
                    // Check if quest complete
                    if (this.questData.objectives.every(o => o.completed)) {
                        this.gainXP(this.questData.xpReward, 'Quest Complete: ' + this.questData.current);
                        this.showDevAchievement('Quest Complete!', this.questData.current);
                        this.generateNewQuest();
                    }
                }
            }

            generateNewQuest() {
                const quests = [
                    {
                        name: 'Performance Blackflame',
                        objectives: [
                            'Profile render performance',
                            'Optimize animation loops',
                            'Reduce memory footprint by 20%',
                            'Implement lazy loading',
                            'Add performance monitoring'
                        ],
                        xpReward: 250
                    },
                    {
                        name: 'Save System Sage',
                        objectives: [
                            'Implement cloud saves',
                            'Add save compression',
                            'Create save backup system',
                            'Add save versioning',
                            'Test save migration'
                        ],
                        xpReward: 300
                    }
                ];
                
                const newQuest = quests[Math.floor(Math.random() * quests.length)];
                this.questData.current = newQuest.name;
                this.questData.objectives = newQuest.objectives.map(text => ({ text, completed: false }));
                this.questData.xpReward = newQuest.xpReward;
                this.updateQuestUI();
            }

            gainXP(amount, reason = '') {
                this.devData.xp += amount;
                this.showXPGain(amount);
                
                // Check for advancement
                const currentLevel = this.getCurrentAdvancement();
                const nextLevel = this.getNextAdvancement();
                
                if (nextLevel && this.devData.xp >= nextLevel.xp) {
                    this.advance(nextLevel);
                }
                
                // Update streak with safe storage
                const today = new Date().toDateString();
                let lastCommit = null;
                
                try {
                    if (saveMethod === 'localStorage') {
                        lastCommit = localStorage.getItem('lastCommitDate');
                    } else {
                        lastCommit = memorySaves['lastCommitDate'];
                    }
                } catch (e) {
                    console.log('Could not check last commit date');
                }
                
                if (lastCommit !== today) {
                    this.devData.streak++;
                    try {
                        if (saveMethod === 'localStorage') {
                            localStorage.setItem('lastCommitDate', today);
                        } else {
                            memorySaves['lastCommitDate'] = today;
                        }
                    } catch (e) {
                        console.log('Could not save last commit date');
                    }
                }
                
                this.updateUI();
                this.saveDevProgress();
                
                if (reason) {
                    this.addFeedItem('xp', reason);
                }
            }

            getCurrentAdvancement() {
                let current = this.devAdvancements[0];
                for (const level of this.devAdvancements) {
                    if (this.devData.xp >= level.xp) {
                        current = level;
                    } else {
                        break;
                    }
                }
                return current;
            }

            getNextAdvancement() {
                const current = this.getCurrentAdvancement();
                const index = this.devAdvancements.indexOf(current);
                return this.devAdvancements[index + 1];
            }

            advance(level) {
                this.devData.advancement = level.name;
                this.devData.path = `Path of the ${level.title}`;
                this.devData.maxXP = this.devAdvancements[this.devAdvancements.indexOf(level) + 1]?.xp || level.xp * 2;
                
                this.showDevAchievement(`Advanced to ${level.name}!`, level.title);
                
                // Unlock new techniques
                if (level.name === 'Jade') {
                    this.devData.techniques.blackflameOptimization = 1;
                }
                
                // Dispatch event for game integration
                document.dispatchEvent(new CustomEvent('devAdvancement', {
                    detail: { level: level.name, title: level.title }
                }));
            }

            showXPGain(amount) {
                const effect = document.createElement('div');
                effect.className = 'xp-gain-effect';
                effect.textContent = `+${amount} XP`;
                document.body.appendChild(effect);
                
                setTimeout(() => effect.remove(), 2000);
            }

            showDevAchievement(title, description) {
                const popup = document.getElementById('devAchievementPopup');
                document.getElementById('devAchievementText').innerHTML = `<strong>${title}</strong><br>${description}`;
                
                popup.classList.add('show');
                setTimeout(() => popup.classList.remove('show'), 4000);
            }

            updateSyncStatus(message, type) {
                const syncStatus = document.getElementById('syncStatus');
                syncStatus.textContent = message;
                
                syncStatus.style.color = {
                    success: '#00ff88',
                    error: '#ff4444',
                    connecting: '#ffaa00'
                }[type] || 'white';
            }

            updateUI() {
                // Update advancement display
                const current = this.getCurrentAdvancement();
                const next = this.getNextAdvancement();
                
                document.getElementById('devRank').textContent = `${current.name} Body`;
                document.getElementById('devPath').textContent = this.devData.path;
                document.getElementById('devXP').textContent = this.devData.xp;
                document.getElementById('devMaxXP').textContent = next ? next.xp : this.devData.maxXP;
                
                // Update XP bar
                const xpPercent = next ? ((this.devData.xp - current.xp) / (next.xp - current.xp) * 100) : 100;
                document.getElementById('devXPFill').style.width = Math.min(xpPercent, 100) + '%';
                
                // Update stats
                document.getElementById('totalCommits').textContent = this.devData.totalCommits;
                document.getElementById('devStreak').textContent = this.devData.streak;
                document.getElementById('bugsFoxed').textContent = this.devData.bugsFoxed;
                document.getElementById('featuresShipped').textContent = this.devData.featuresShipped;
                
                this.updateQuestUI();
            }

            updateQuestUI() {
                const completed = this.questData.objectives.filter(o => o.completed).length;
                const total = this.questData.objectives.length;
                const progress = (completed / total) * 100;
                
                document.getElementById('currentQuestProgress').style.width = progress + '%';
                
                // Update checkboxes
                const checkboxes = document.querySelectorAll('.quest-checkbox');
                this.questData.objectives.forEach((objective, index) => {
                    if (checkboxes[index]) {
                        if (objective.completed) {
                            checkboxes[index].classList.add('completed');
                        } else {
                            checkboxes[index].classList.remove('completed');
                        }
                    }
                });
            }

            addFeedItem(type, content) {
                const feed = document.getElementById('devFeed');
                const item = document.createElement('div');
                item.className = `feed-item feed-${type}`;
                item.textContent = content;
                
                feed.insertBefore(item, feed.firstChild);
                
                // Keep only last 10 items
                while (feed.children.length > 10) {
                    feed.removeChild(feed.lastChild);
                }
            }

            startPeriodicSync() {
                this.syncInterval = setInterval(() => {
                    if (this.githubConnected) {
                        this.syncRepositoryData();
                    }
                }, 120000); // 2 minutes
            }

            handleGameProgress(progressData) {
                switch (progressData.type) {
                    case 'quest_complete':
                        this.gainXP(progressData.xp || 50, progressData.description);
                        break;
                    case 'bug_fixed':
                        this.devData.bugsFoxed++;
                        this.gainXP(50, 'Bug crushed!');
                        break;
                    case 'feature_complete':
                        this.devData.featuresShipped++;
                        this.gainXP(100, 'Feature shipped!');
                        break;
                    case 'commit':
                        this.devData.totalCommits++;
                        this.gainXP(30, 'Code committed');
                        break;
                }
                this.updateUI();
            }
        }

        // Initialize dev tracker
        const devTracker = new DevTracker();

        // GAME ENGINE
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            const aspectRatio = 4 / 3;
            let newWidth, newHeight;
            
            if (containerWidth / containerHeight > aspectRatio) {
                newHeight = containerHeight;
                newWidth = newHeight * aspectRatio;
            } else {
                newWidth = containerWidth;
                newHeight = newWidth / aspectRatio;
            }
            
            canvas.width = 800;
            canvas.height = 600;
            
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
            
            canvas.style.position = 'absolute';
            canvas.style.left = '50%';
            canvas.style.top = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game state
        const game = {
            mode: 'exploration',
            player: {
                x: 400,
                y: 300,
                health: 100,
                maxHealth: 100,
                madra: 100,
                maxMadra: 100,
                madraCollected: 0,
                advancement: 'Unsouled',
                speed: 3,
                combatWins: 0,
                techniques: ['punch', 'kick', 'emptyPalm']
            },
            camera: {
                x: 0,
                y: 0
            },
            combat: {
                playerX: 200,
                playerY: 400,
                playerVelY: 0,
                playerState: 'idle',
                playerFacing: 1,
                enemyX: 600,
                enemyY: 400,
                enemyHealth: 100,
                enemyMaxHealth: 100,
                enemyState: 'idle',
                enemyType: null,
                combo: 0,
                lastHit: 0,
                blockActive: false
            },
            world: {
                width: 1600,
                height: 1200,
                tiles: [],
                entities: [],
                npcs: []
            },
            saveSlot: 1,
            lastSaveTime: 0,
            paused: false
        };

        // Input handling
        const keys = {};
        const touches = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            isMoving: false,
            joystickActive: false
        };
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        window.addEventListener('keydown', (e) => {
            // PIN input keyboard support
            if (document.getElementById('devLoginModal').style.display === 'block') {
                const input = document.getElementById('pinInput');
                if (e.key >= '0' && e.key <= '9' && input.value.length < 4) {
                    addPin(e.key);
                } else if (e.key === 'Enter') {
                    submitPin();
                } else if (e.key === 'Backspace') {
                    clearPin();
                } else if (e.key === 'Escape') {
                    hideDevLogin();
                }
                e.preventDefault();
                return;
            }
            
            keys[e.key.toLowerCase()] = true;
            
            // Dev tracker hotkey
            if (e.key.toLowerCase() === 't') {
                e.preventDefault();
                if (devModeUnlocked) {
                    toggleDevTracker();
                } else {
                    showDevLogin();
                }
            }
            
            if (e.key === 'F5') {
                e.preventDefault();
                saveGame();
                devTracker.handleGameProgress({ type: 'feature_complete', description: 'Save system tested!' });
            }
            if (e.key === 'F9') {
                e.preventDefault();
                loadGame(game.saveSlot);
            }
            if (e.key.toLowerCase() === 'm' && game.mode === 'exploration') {
                e.preventDefault();
                openSaveMenu();
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                closeSaveMenu();
                hideControls();
            }
            if (e.key.toLowerCase() === 'c') {
                e.preventDefault();
                toggleControls();
            }
            if (e.key === '?') {
                e.preventDefault();
                showControls();
            }
            
            if (['w', 'a', 's', 'd', 'j', 'k', 'l', ' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            e.preventDefault();
        });
        
        // Global functions
        function toggleDevTracker() {
            if (devModeUnlocked) {
                devTracker.toggle();
            } else {
                showDevLogin();
            }
        }

        function connectToGitHub() {
            devTracker.connectToGitHub();
        }

        function syncNow() {
            devTracker.syncRepositoryData();
        }
        
        function toggleControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv && controlsDiv.style.display === 'block') {
                hideControls();
            } else {
                showControls();
            }
        }
        
        function showControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv) {
                controlsDiv.style.display = 'block';
                game.paused = true;
                const hint = document.getElementById('controlsHint');
                if (hint) hint.style.display = 'none';
            }
        }
        
        function hideControls() {
            const controlsDiv = document.getElementById('fullControls');
            if (controlsDiv) {
                controlsDiv.style.display = 'none';
                game.paused = false;
            }
        }
        
        window.toggleControls = toggleControls;
        window.showControls = showControls;
        window.hideControls = hideControls;
        
        let firstInteraction = true;
        window.addEventListener('keydown', () => {
            if (firstInteraction) {
                firstInteraction = false;
                setTimeout(() => {
                    const hint = document.getElementById('controlsHint');
                    if (hint) hint.style.display = 'none';
                }, 5000);
            }
        });
        
        // Touch handling with fixes
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            touches.startX = x;
            touches.startY = y;
            touches.currentX = x;
            touches.currentY = y;
            
            if (game.mode === 'exploration') {
                if (x < canvas.width / 3) {
                    touches.joystickActive = true;
                    touches.isMoving = true;
                }
                else if (x > canvas.width * 2/3) {
                    keys[' '] = true;
                    setTimeout(() => keys[' '] = false, 100);
                }
            } else if (game.mode === 'combat') {
                if (x < canvas.width / 4) {
                    keys['a'] = true;
                } else if (x > canvas.width * 3/4) {
                    keys['d'] = true;
                } else if (y < canvas.height / 2) {
                    keys[' '] = true;
                } else {
                    if (x < canvas.width / 2) {
                        keys['j'] = true;
                    } else {
                        keys['k'] = true;
                    }
                }
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (!touches.isMoving) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touches.currentX = touch.clientX - rect.left;
            touches.currentY = touch.clientY - rect.top;
            
            if (touches.joystickActive && game.mode === 'exploration') {
                const dx = touches.currentX - touches.startX;
                const dy = touches.currentY - touches.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
                
                if (distance > 20) {
                    const angle = Math.atan2(dy, dx);
                    
                    if (angle > -Math.PI/8 && angle <= Math.PI/8) {
                        keys['d'] = true;
                    } else if (angle > Math.PI/8 && angle <= 3*Math.PI/8) {
                        keys['d'] = true;
                        keys['s'] = true;
                    } else if (angle > 3*Math.PI/8 && angle <= 5*Math.PI/8) {
                        keys['s'] = true;
                    } else if (angle > 5*Math.PI/8 && angle <= 7*Math.PI/8) {
                        keys['a'] = true;
                        keys['s'] = true;
                    } else if (angle > 7*Math.PI/8 || angle <= -7*Math.PI/8) {
                        keys['a'] = true;
                    } else if (angle > -7*Math.PI/8 && angle <= -5*Math.PI/8) {
                        keys['a'] = true;
                        keys['w'] = true;
                    } else if (angle > -5*Math.PI/8 && angle <= -3*Math.PI/8) {
                        keys['w'] = true;
                    } else if (angle > -3*Math.PI/8 && angle <= -Math.PI/8) {
                        keys['d'] = true;
                        keys['w'] = true;
                    }
                }
            }
        }

        // Fixed handleTouchEnd function
        function handleTouchEnd(e) {
            e.preventDefault();
            touches.isMoving = false;
            touches.joystickActive = false;
            
            // Smooth knob return animation
            const knob = document.getElementById('joystickKnob');
            if (knob) {
                knob.style.transition = 'transform 0.2s ease';
                knob.style.transform = 'translate(-50%, -50%)';
                setTimeout(() => {
                    knob.style.transition = 'none';
                }, 200);
            }
            
            // Clear ALL keys to prevent drift
            Object.keys(keys).forEach(key => keys[key] = false);
            
            // Dev achievement for fixing touch controls
            if (Math.random() > 0.8) {
                devTracker.updateQuestProgress(true);
            }
        }

        // Initialize save system early
        let saveMethod = 'none';
        const memorySaves = {};
        
        // Test save method immediately
        (function initializeSaveSystem() {
            try {
                // Test if localStorage is accessible
                if (typeof(Storage) !== "undefined" && window.localStorage) {
                    localStorage.setItem('test', 'test');
                    localStorage.removeItem('test');
                    saveMethod = 'localStorage';
                    console.log('Using localStorage for saves');
                } else {
                    throw new Error('localStorage not available');
                }
            } catch (e) {
                // Fallback to memory saves
                saveMethod = 'memory';
                console.log('Using memory saves (temporary) - ' + e.message);
            }
        })();
        
        function saveGame(slot = game.saveSlot) {
            const saveData = {
                player: {
                    x: game.player.x,
                    y: game.player.y,
                    health: game.player.health,
                    maxHealth: game.player.maxHealth,
                    madra: game.player.madra,
                    maxMadra: game.player.maxMadra,
                    madraCollected: game.player.madraCollected,
                    advancement: game.player.advancement,
                    speed: game.player.speed,
                    combatWins: game.player.combatWins,
                    techniques: [...game.player.techniques]
                },
                world: {
                    entities: game.world.entities.map(e => ({
                        type: e.type,
                        x: e.x,
                        y: e.y,
                        collected: e.collected,
                        enemyType: e.enemyType,
                        health: e.health
                    }))
                },
                timestamp: Date.now(),
                playTime: Date.now() - game.lastSaveTime
            };
            
            try {
                if (saveMethod === 'localStorage') {
                    localStorage.setItem(`cradleSave_${slot}`, JSON.stringify(saveData));
                } else {
                    memorySaves[`cradleSave_${slot}`] = JSON.stringify(saveData);
                }
                
                showSaveNotification('Game Saved!');
                game.lastSaveTime = Date.now();
                
                if (saveMethod === 'memory') {
                    offerDownloadSave(saveData, slot);
                }
                
                return true;
            } catch (e) {
                console.error('Save error:', e);
                showSaveNotification('Save Failed! Check browser settings.', true);
                return false;
            }
        }
        
        function offerDownloadSave(saveData, slot) {
            const dataStr = JSON.stringify(saveData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `cradle_save_slot_${slot}.json`;
            
            const downloadPrompt = document.createElement('div');
            downloadPrompt.style.cssText = `
                position: absolute;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: #000;
                border: 2px solid #0f0;
                padding: 10px;
                color: #0f0;
                text-align: center;
                z-index: 1000;
            `;
            downloadPrompt.innerHTML = `
                <p>Browser storage unavailable!</p>
                <button onclick="this.parentElement.querySelector('a').click()" style="padding: 5px 10px; cursor: pointer;">Download Save File</button>
                <button onclick="this.parentElement.remove()" style="padding: 5px 10px; margin-left: 10px; cursor: pointer;">Cancel</button>
            `;
            downloadPrompt.appendChild(link);
            document.getElementById('gameContainer').appendChild(downloadPrompt);
            
            setTimeout(() => downloadPrompt.remove(), 10000);
        }

        function loadGame(slot = 1) {
            try {
                let saveData;
                
                if (saveMethod === 'localStorage') {
                    saveData = localStorage.getItem(`cradleSave_${slot}`);
                } else {
                    saveData = memorySaves[`cradleSave_${slot}`];
                }
                
                if (!saveData) return false;
                
                const data = JSON.parse(saveData);
                
                Object.assign(game.player, data.player);
                
                generateWorld();
                
                if (data.world && data.world.entities) {
                    game.world.entities = game.world.entities.filter(entity => {
                        const savedEntity = data.world.entities.find(e => 
                            e.type === entity.type && 
                            Math.abs(e.x - entity.x) < 50 && 
                            Math.abs(e.y - entity.y) < 50
                        );
                        
                        if (savedEntity) {
                            if (savedEntity.type === 'madra' && savedEntity.collected) {
                                return false;
                            }
                            if (savedEntity.type === 'enemy' && !savedEntity.health) {
                                return false;
                            }
                            if (savedEntity.type === 'enemy') {
                                entity.health = savedEntity.health;
                            }
                        }
                        return true;
                    });
                }
                
                game.lastSaveTime = Date.now();
                updateUI();
                showSaveNotification('Game Loaded!');
                return true;
            } catch (e) {
                console.error('Load error:', e);
                showSaveNotification('Load Failed!', true);
                return false;
            }
        }

        function getSaveInfo(slot) {
            try {
                let saveData;
                
                if (saveMethod === 'localStorage') {
                    saveData = localStorage.getItem(`cradleSave_${slot}`);
                } else {
                    saveData = memorySaves[`cradleSave_${slot}`];
                }
                
                if (!saveData) return null;
                
                const data = JSON.parse(saveData);
                return {
                    advancement: data.player.advancement,
                    madraCollected: data.player.madraCollected,
                    combatWins: data.player.combatWins,
                    timestamp: data.timestamp,
                    playTime: data.playTime
                };
            } catch (e) {
                return null;
            }
        }

        function deleteSave(slot) {
            try {
                if (saveMethod === 'localStorage') {
                    localStorage.removeItem(`cradleSave_${slot}`);
                } else {
                    delete memorySaves[`cradleSave_${slot}`];
                }
                showSaveNotification('Save Deleted!');
                return true;
            } catch (e) {
                return false;
            }
        }

        function showSaveNotification(text, isError = false) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${isError ? '#ff0000' : '#00ff00'};
                color: black;
                padding: 10px 20px;
                font-size: 20px;
                font-weight: bold;
                border: 2px solid white;
                z-index: 1000;
            `;
            notification.textContent = text;
            document.getElementById('gameContainer').appendChild(notification);
            
            setTimeout(() => notification.remove(), 1500);
        }

        function autoSave() {
            if (game.mode === 'exploration' && Date.now() - game.lastSaveTime > 30000) {
                saveGame();
            }
        }

        function openSaveMenu() {
            const menu = document.getElementById('saveMenu');
            const slotsDiv = document.getElementById('saveSlots');
            
            slotsDiv.innerHTML = '';
            
            for (let i = 1; i <= 3; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.style.cssText = 'margin: 10px 0; padding: 15px; border: 2px solid #666; background: #111;';
                
                const saveInfo = getSaveInfo(i);
                
                if (saveInfo) {
                    const date = new Date(saveInfo.timestamp);
                    slotDiv.innerHTML = `
                        <h3>Slot ${i} ${i === game.saveSlot ? '(Current)' : ''}</h3>
                        <p>${saveInfo.advancement} - Madra: ${saveInfo.madraCollected} - Wins: ${saveInfo.combatWins}</p>
                        <p>Saved: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}</p>
                        <button onclick="saveToSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Save Here</button>
                        <button onclick="loadFromSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Load</button>
                        <button onclick="deleteSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer; background: #f00;">Delete</button>
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <h3>Slot ${i} - Empty</h3>
                        <button onclick="saveToSlot(${i})" style="margin: 5px; padding: 5px 10px; cursor: pointer;">Save Here</button>
                    `;
                }
                
                slotsDiv.appendChild(slotDiv);
            }
            
            menu.style.display = 'block';
            game.paused = true;
        }

        function closeSaveMenu() {
            document.getElementById('saveMenu').style.display = 'none';
            game.paused = false;
        }

        function saveToSlot(slot) {
            game.saveSlot = slot;
            saveGame(slot);
            openSaveMenu();
        }

        function loadFromSlot(slot) {
            game.saveSlot = slot;
            if (loadGame(slot)) {
                closeSaveMenu();
            }
        }

        function deleteSlot(slot) {
            if (confirm(`Delete save in slot ${slot}?`)) {
                deleteSave(slot);
                openSaveMenu();
            }
        }

        // World generation
        function generateWorld() {
            game.world.tiles = [];
            game.world.entities = [];
            game.world.npcs = [];
            
            // Create basic tile grid
            for (let y = 0; y < game.world.height; y += 40) {
                for (let x = 0; x < game.world.width; x += 40) {
                    const tile = {
                        x: x,
                        y: y,
                        type: 'grass'
                    };
                    
                    if (Math.random() < 0.1) tile.type = 'stone';
                    if (Math.random() < 0.05) tile.type = 'flower';
                    
                    game.world.tiles.push(tile);
                }
            }

            // Add walls
            for (let x = 0; x < game.world.width; x += 40) {
                game.world.tiles.push({ x: x, y: 0, type: 'wall' });
                game.world.tiles.push({ x: x, y: game.world.height - 40, type: 'wall' });
            }
            for (let y = 0; y < game.world.height; y += 40) {
                game.world.tiles.push({ x: 0, y: y, type: 'wall' });
                game.world.tiles.push({ x: game.world.width - 40, y: y, type: 'wall' });
            }

            // Add madra orbs
            for (let i = 0; i < 20; i++) {
                game.world.entities.push({
                    type: 'madra',
                    x: Math.random() * (game.world.width - 100) + 50,
                    y: Math.random() * (game.world.height - 100) + 50,
                    collected: false,
                    pulse: 0
                });
            }

            // Add enemies
            const enemyTypes = ['student', 'iron', 'jade'];
            for (let i = 0; i < 8; i++) {
                game.world.entities.push({
                    type: 'enemy',
                    enemyType: enemyTypes[Math.floor(Math.random() * enemyTypes.length)],
                    x: Math.random() * (game.world.width - 200) + 100,
                    y: Math.random() * (game.world.height - 200) + 100,
                    health: 100,
                    patrol: {
                        startX: 0,
                        startY: 0,
                        direction: 1
                    }
                });
            }

            // Add NPCs
            game.world.npcs.push({
                name: 'Elder Whisper',
                x: 800,
                y: 600,
                dialogue: [
                    "The path of the Unsouled is difficult, but not impossible.",
                    "Collect madra from the sacred orbs scattered across the valley.",
                    "Prove yourself in combat, and perhaps you'll advance beyond Copper.",
                    "A developer's path mirrors a sacred artist's - both require patience and practice."
                ]
            });

            // Initialize patrol positions
            game.world.entities.forEach(entity => {
                if (entity.type === 'enemy') {
                    entity.patrol.startX = entity.x;
                    entity.patrol.startY = entity.y;
                }
            });
        }

        // Game update functions
        function updateExploration() {
            if (game.paused) return;
            
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy = -game.player.speed;
            if (keys['s'] || keys['arrowdown']) dy = game.player.speed;
            if (keys['a'] || keys['arrowleft']) dx = -game.player.speed;
            if (keys['d'] || keys['arrowright']) dx = game.player.speed;

            const newX = game.player.x + dx;
            const newY = game.player.y + dy;
            
            let canMove = true;
            game.world.tiles.forEach(tile => {
                if (tile.type === 'wall') {
                    if (newX < tile.x + 40 && newX + 20 > tile.x &&
                        newY < tile.y + 40 && newY + 20 > tile.y) {
                        canMove = false;
                    }
                }
            });

            if (canMove) {
                game.player.x = Math.max(20, Math.min(game.world.width - 40, newX));
                game.player.y = Math.max(20, Math.min(game.world.height - 40, newY));
            }

            // Update camera
            game.camera.x = Math.max(0, Math.min(game.world.width - canvas.width, 
                game.player.x - canvas.width / 2));
            game.camera.y = Math.max(0, Math.min(game.world.height - canvas.height, 
                game.player.y - canvas.height / 2));

            // Update entities
            game.world.entities.forEach(entity => {
                const dist = Math.hypot(entity.x - game.player.x, entity.y - game.player.y);
                
                if (entity.type === 'madra' && !entity.collected && dist < 30) {
                    entity.collected = true;
                    game.player.madraCollected += 10;
                    game.player.madra = Math.min(game.player.maxMadra, game.player.madra + 20);
                    createFloatingText('+10 Madra', entity.x - game.camera.x, entity.y - game.camera.y);
                    checkAdvancement();
                    
                    // Dispatch event for dev tracker
                    document.dispatchEvent(new CustomEvent('madraCollected', {
                        detail: { amount: 10, total: game.player.madraCollected }
                    }));
                }
                
                if (entity.type === 'enemy' && dist < 40) {
                    startCombat(entity);
                }

                if (entity.type === 'madra' && !entity.collected) {
                    entity.pulse += 0.1;
                }
                
                if (entity.type === 'enemy') {
                    entity.x += entity.patrol.direction * 0.5;
                    if (Math.abs(entity.x - entity.patrol.startX) > 100) {
                        entity.patrol.direction *= -1;
                    }
                }
            });

            // NPC interaction
            if (keys[' '] && (!game.dialogue || !game.dialogue.active)) {
                game.world.npcs.forEach(npc => {
                    const dist = Math.hypot(npc.x - game.player.x, npc.y - game.player.y);
                    if (dist < 50) {
                        if (npc.dialogue && npc.dialogue.length > 0) {
                            const dialogueIndex = Math.floor(Math.random() * npc.dialogue.length);
                            showDialogue(npc.dialogue[dialogueIndex], npc.name);
                        }
                    }
                });
            }
            
            if ((keys[' '] || keys['escape']) && game.dialogue && game.dialogue.active && !game.dialogue.choices) {
                hideDialogue();
                keys[' '] = false;
            }
        }

        function startCombat(enemy) {
            game.mode = 'combat';
            game.combat.enemyType = enemy.enemyType;
            game.combat.enemyHealth = game.combat.enemyMaxHealth = enemy.health;
            game.combat.playerX = 200;
            game.combat.enemyX = 600;
            game.combat.playerY = game.combat.enemyY = 400;
            game.combat.playerState = game.combat.enemyState = 'idle';
            game.combat.combo = 0;
            
            document.getElementById('explorationInstructions').style.display = 'none';
            document.getElementById('combatInstructions').style.display = 'block';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('combatUI').style.display = 'block';
            document.getElementById('enemyName').textContent = enemy.enemyType.toUpperCase();
            
            if (isMobile) {
                document.getElementById('explorationControls').style.display = 'none';
                document.getElementById('combatControls').style.display = 'block';
            }
            
            flashScreen();
            
            const index = game.world.entities.indexOf(enemy);
            if (index > -1) {
                game.world.entities.splice(index, 1);
            }
        }

        function updateCombat() {
            if (keys['a']) {
                game.combat.playerX = Math.max(50, game.combat.playerX - 5);
                game.combat.playerFacing = -1;
            }
            if (keys['d']) {
                game.combat.playerX = Math.min(400, game.combat.playerX + 5);
                game.combat.playerFacing = 1;
            }
            
            if (keys['j'] && game.combat.playerState === 'idle') {
                performAttack('punch', 10, 0);
            }
            if (keys['k'] && game.combat.playerState === 'idle') {
                performAttack('kick', 15, 0);
            }
            if (keys[' '] && game.combat.playerState === 'idle' && game.player.madra >= 30) {
                performAttack('emptyPalm', 0, 30);
            }
            
            game.combat.blockActive = keys['l'];

            if (game.combat.playerState === 'attacking') {
                setTimeout(() => {
                    game.combat.playerState = 'idle';
                }, 300);
            }

            // Enemy AI
            const distance = Math.abs(game.combat.enemyX - game.combat.playerX);
            
            if (game.combat.enemyStunnedUntil && Date.now() < game.combat.enemyStunnedUntil) {
                game.combat.enemyState = 'stunned';
            } else if (game.combat.enemyState === 'stunned') {
                game.combat.enemyState = 'idle';
                game.combat.enemyStunnedUntil = null;
            }
            
            if (game.combat.enemyState === 'idle') {
                if (distance > 100) {
                    game.combat.enemyX += game.combat.enemyX > game.combat.playerX ? -3 : 3;
                } else if (Math.random() < 0.02) {
                    game.combat.enemyState = 'attacking';
                    setTimeout(() => {
                        if (distance < 100 && !game.combat.blockActive && game.combat.enemyState !== 'stunned') {
                            game.player.health = Math.max(0, game.player.health - 10);
                            game.combat.combo = 0;
                            screenShake();
                        }
                        if (game.combat.enemyState !== 'stunned') {
                            game.combat.enemyState = 'idle';
                        }
                    }, 400);
                }
            }

            // Check win/loss conditions
            if (game.combat.enemyHealth <= 0) {
                endCombat(true);
            } else if (game.player.health <= 0) {
                endCombat(false);
            }

            // Update UI
            document.getElementById('combatPlayerHealth').style.width = 
                (game.player.health / game.player.maxHealth * 100) + '%';
            document.getElementById('combatPlayerMadra').style.width = 
                (game.player.madra / game.player.maxMadra * 100) + '%';
            document.getElementById('combatEnemyHealth').style.width = 
                (game.combat.enemyHealth / game.combat.enemyMaxHealth * 100) + '%';
        }

        function performAttack(type, damage, madraCost) {
            game.combat.playerState = 'attacking';
            
            const distance = Math.abs(game.combat.enemyX - game.combat.playerX);
            
            if (type === 'emptyPalm') {
                if (game.player.madra >= 30) {
                    game.player.madra -= 30;
                    
                    let stunDuration = 500;
                    if (game.player.advancement === 'Copper') stunDuration = 1000;
                    if (game.player.advancement === 'Iron') stunDuration = 1500;
                    if (game.player.advancement === 'Jade') stunDuration = 2000;
                    if (game.player.advancement === 'Gold') stunDuration = 2500;
                    
                    game.combat.enemyState = 'stunned';
                    game.combat.enemyStunnedUntil = Date.now() + stunDuration;
                    
                    flashScreen();
                    createFloatingText('DISRUPTED!', game.combat.enemyX, game.combat.enemyY - 50);
                    
                    game.combat.emptyPalmWindow = true;
                    setTimeout(() => {
                        game.combat.emptyPalmWindow = false;
                    }, stunDuration);
                }
            } else if (distance < 100) {
                let finalDamage = damage;
                if (game.combat.emptyPalmWindow) {
                    finalDamage = Math.floor(damage * 1.5);
                    createFloatingText('CRITICAL!', game.combat.enemyX, game.combat.enemyY - 80);
                }
                
                game.combat.enemyHealth = Math.max(0, game.combat.enemyHealth - finalDamage);
                game.combat.combo++;
                game.combat.lastHit = Date.now();
                
                if (game.combat.combo > 1) {
                    document.getElementById('comboCount').textContent = game.combat.combo;
                    document.getElementById('comboCounter').style.display = 'block';
                }
                
                screenShake();
                createFloatingText(finalDamage + ' DMG', game.combat.enemyX, game.combat.enemyY - 50);
            }
        }

        function endCombat(victory) {
            game.mode = 'exploration';
            document.getElementById('explorationInstructions').style.display = 'block';
            document.getElementById('combatInstructions').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('combatUI').style.display = 'none';
            document.getElementById('comboCounter').style.display = 'none';
            
            if (isMobile) {
                document.getElementById('explorationControls').style.display = 'block';
                document.getElementById('combatControls').style.display = 'none';
            }
            
            if (victory) {
                game.player.combatWins++;
                game.player.madraCollected += 50;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + 20);
                showDialogue("Victory! You've gained strength from combat.");
                checkAdvancement();
                saveGame();
                
                // Dispatch event for dev tracker
                document.dispatchEvent(new CustomEvent('combatVictory', {
                    detail: { enemyType: game.combat.enemyType }
                }));
                
                devTracker.handleGameProgress({ 
                    type: 'bug_fixed', 
                    description: 'Combat test passed!' 
                });
            } else {
                game.player.health = game.player.maxHealth;
                game.player.x = 400;
                game.player.y = 300;
                showDialogue("Defeated... but you rise again, determined.");
            }
            
            updateUI();
        }

        function checkAdvancement() {
            const advancements = [
                { name: 'Copper', madra: 100, wins: 2 },
                { name: 'Iron', madra: 300, wins: 5 },
                { name: 'Jade', madra: 600, wins: 10 },
                { name: 'Gold', madra: 1000, wins: 20 }
            ];
            
            advancements.forEach(level => {
                if (game.player.advancement !== level.name && 
                    game.player.madraCollected >= level.madra && 
                    game.player.combatWins >= level.wins) {
                    game.player.advancement = level.name;
                    game.player.maxHealth += 50;
                    game.player.maxMadra += 50;
                    game.player.health = game.player.maxHealth;
                    game.player.madra = game.player.maxMadra;
                    game.player.speed += 1;
                    
                    showAdvancement(level.name);
                    
                    // Dispatch event for dev tracker
                    document.dispatchEvent(new CustomEvent('playerAdvancement', {
                        detail: { level: level.name }
                    }));
                }
            });
        }

        function showAdvancement(level) {
            const notice = document.getElementById('advancementNotice');
            notice.innerHTML = `ADVANCEMENT!<br>You have reached ${level}!`;
            notice.style.display = 'block';
            flashScreen();
            
            setTimeout(() => {
                notice.style.display = 'none';
            }, 3000);
        }

        // Rendering functions
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (game.mode === 'exploration') {
                renderExploration();
            } else {
                renderCombat();
            }
        }

        function renderExploration() {
            // Render tiles
            game.world.tiles.forEach(tile => {
                const screenX = tile.x - game.camera.x;
                const screenY = tile.y - game.camera.y;
                
                if (screenX > -40 && screenX < canvas.width && 
                    screenY > -40 && screenY < canvas.height) {
                    
                    ctx.fillStyle = tile.type === 'grass' ? '#2d5016' : 
                                   tile.type === 'stone' ? '#444' :
                                   tile.type === 'flower' ? '#2d5016' : '#222';
                    ctx.fillRect(screenX, screenY, 40, 40);
                    
                    if (tile.type === 'flower') {
                        ctx.fillStyle = '#ff69b4';
                        ctx.fillRect(screenX + 15, screenY + 15, 10, 10);
                    }
                }
            });

            // Render entities
            game.world.entities.forEach(entity => {
                const screenX = entity.x - game.camera.x;
                const screenY = entity.y - game.camera.y;
                
                if (entity.type === 'madra' && !entity.collected) {
                    const pulse = Math.sin(entity.pulse) * 5;
                    ctx.fillStyle = '#00ccff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ccff';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 15 + pulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                if (entity.type === 'enemy') {
                    ctx.fillStyle = entity.enemyType === 'student' ? '#654321' :
                                   entity.enemyType === 'iron' ? '#888' : '#0f0';
                    ctx.fillRect(screenX - 15, screenY - 30, 30, 40);
                    
                    ctx.fillStyle = '#fdbcb4';
                    ctx.fillRect(screenX - 10, screenY - 40, 20, 20);
                }
            });

            // Render NPCs
            game.world.npcs.forEach(npc => {
                const screenX = npc.x - game.camera.x;
                const screenY = npc.y - game.camera.y;
                
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(screenX - 20, screenY - 40, 40, 50);
                
                ctx.fillStyle = '#fdbcb4';
                ctx.fillRect(screenX - 15, screenY - 55, 30, 25);
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(npc.name, screenX, screenY - 65);
            });

            // Render player
            const playerScreenX = game.player.x - game.camera.x;
            const playerScreenY = game.player.y - game.camera.y;
            
            ctx.fillStyle = game.player.advancement === 'Unsouled' ? '#333' :
                           game.player.advancement === 'Copper' ? '#b87333' :
                           game.player.advancement === 'Iron' ? '#888' :
                           game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
            ctx.fillRect(playerScreenX - 10, playerScreenY - 20, 20, 30);
            
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(playerScreenX - 8, playerScreenY - 30, 16, 16);
            
            if (game.player.advancement !== 'Unsouled') {
                ctx.strokeStyle = game.player.advancement === 'Copper' ? '#b87333' :
                                 game.player.advancement === 'Iron' ? '#888' :
                                 game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(playerScreenX - 15, playerScreenY - 35, 30, 40);
            }
        }

        function renderCombat() {
            // Combat arena
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 450, canvas.width, 150);
            
            // Render player
            ctx.save();
            ctx.translate(game.combat.playerX, game.combat.playerY);
            ctx.scale(game.combat.playerFacing, 1);
            
            ctx.fillStyle = game.player.advancement === 'Unsouled' ? '#333' :
                           game.player.advancement === 'Copper' ? '#b87333' :
                           game.player.advancement === 'Iron' ? '#888' :
                           game.player.advancement === 'Jade' ? '#0f0' : '#ffd700';
            ctx.fillRect(-20, -60, 40, 60);
            
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-15, -75, 30, 25);
            
            if (game.combat.playerState === 'attacking') {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(20, -40, 30, 10);
            }
            
            if (game.combat.blockActive) {
                ctx.strokeStyle = '#00f';
                ctx.lineWidth = 3;
                ctx.strokeRect(-30, -80, 60, 80);
            }
            
            ctx.restore();
            
            // Render enemy
            ctx.save();
            ctx.translate(game.combat.enemyX, game.combat.enemyY);
            
            ctx.fillStyle = game.combat.enemyType === 'student' ? '#654321' :
                           game.combat.enemyType === 'iron' ? '#888' : '#0f0';
            ctx.fillRect(-20, -60, 40, 60);
            
            ctx.fillStyle = '#fdbcb4';
            ctx.fillRect(-15, -75, 30, 25);
            
            if (game.combat.enemyState === 'stunned') {
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
                ctx.strokeRect(-25, -80, 50, 80);
                ctx.globalAlpha = 1;
                
                for (let i = 0; i < 3; i++) {
                    const angle = (Date.now() * 0.01 + i * 2) % (Math.PI * 2);
                    const x = Math.cos(angle) * 30;
                    const y = Math.sin(angle) * 30 - 40;
                    ctx.fillStyle = '#00ccff';
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                }
            }
            
            if (game.combat.enemyState === 'attacking') {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(-50, -40, 30, 10);
            }
            
            ctx.restore();
        }

        function updateUI() {
            document.getElementById('advancement').textContent = game.player.advancement;
            document.getElementById('playerHealth').style.width = 
                (game.player.health / game.player.maxHealth * 100) + '%';
            document.getElementById('playerMadra').style.width = 
                (game.player.madra / game.player.maxMadra * 100) + '%';
            document.getElementById('madraCount').textContent = game.player.madraCollected;
            document.getElementById('winCount').textContent = game.player.combatWins;
        }

        function showDialogue(text, speaker = '') {
            if (!game.dialogue) {
                game.dialogue = {
                    active: false,
                    speaker: '',
                    text: '',
                    queue: [],
                    choices: null
                };
            }
            
            game.dialogue.active = true;
            game.dialogue.text = text;
            game.dialogue.speaker = speaker;
            game.paused = true;
            
            const dialogueDiv = document.getElementById('dialogue');
            if (dialogueDiv) {
                dialogueDiv.innerHTML = speaker ? `<strong>${speaker}:</strong> ${text}` : text;
                dialogueDiv.style.display = 'block';
            }
        }
        
        function hideDialogue() {
            if (game.dialogue) {
                game.dialogue.active = false;
            }
            game.paused = false;
            const dialogueDiv = document.getElementById('dialogue');
            if (dialogueDiv) {
                dialogueDiv.style.display = 'none';
            }
        }

        function createFloatingText(text, x, y) {
            const div = document.createElement('div');
            div.className = 'floatingText';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.getElementById('gameContainer').appendChild(div);
            
            setTimeout(() => {
                div.remove();
            }, 1000);
        }

        function flashScreen() {
            const flash = document.getElementById('screenFlash');
            flash.style.opacity = '0.8';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 100);
        }

        let shakeAmount = 0;
        function screenShake() {
            shakeAmount = 10;
        }

        function toggleFullscreen() {
            const container = document.getElementById('gameContainer');
            
            if (!document.fullscreenElement) {
                const requestFullscreen = container.requestFullscreen || 
                                        container.mozRequestFullScreen || 
                                        container.webkitRequestFullscreen || 
                                        container.msRequestFullscreen;
                
                if (requestFullscreen) {
                    requestFullscreen.call(container).then(() => {
                        document.getElementById('fullscreenBtn').textContent = '⛶ Exit Fullscreen';
                        resizeCanvas();
                    }).catch(err => {
                        console.log('Fullscreen not available');
                        const btn = document.getElementById('fullscreenBtn');
                        if (btn) btn.style.display = 'none';
                    });
                }
            } else {
                const exitFullscreen = document.exitFullscreen || 
                                     document.mozCancelFullScreen || 
                                     document.webkitExitFullscreen || 
                                     document.msExitFullscreen;
                
                if (exitFullscreen) {
                    exitFullscreen.call(document).then(() => {
                        document.getElementById('fullscreenBtn').textContent = '⛶ Fullscreen';
                        resizeCanvas();
                    });
                }
            }
        }
        
        document.addEventListener('fullscreenchange', resizeCanvas);
        window.toggleFullscreen = toggleFullscreen;
        
        function initializeMobileControls() {
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                touches.joystickActive = true;
                touches.startX = rect.left + rect.width / 2;
                touches.startY = rect.top + rect.height / 2;
                updateJoystick(touch.clientX, touch.clientY);
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (touches.joystickActive) {
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                }
            });
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                touches.joystickActive = false;
                knob.style.transition = 'transform 0.2s ease';
                knob.style.transform = 'translate(-50%, -50%)';
                setTimeout(() => {
                    knob.style.transition = 'none';
                }, 200);
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            });
            
            // Combat buttons
            document.getElementById('actionA').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            
            document.getElementById('actionA').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
            
            document.getElementById('combatMoveLeft').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['a'] = true;
            });
            
            document.getElementById('combatMoveLeft').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['a'] = false;
            });
            
            document.getElementById('combatMoveRight').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['d'] = true;
            });
            
            document.getElementById('combatMoveRight').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['d'] = false;
            });
            
            document.getElementById('actionB').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['j'] = true;
            });
            
            document.getElementById('actionB').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['j'] = false;
            });
            
            document.getElementById('actionSpecial').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            
            document.getElementById('actionSpecial').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
        }
        
        function updateJoystick(touchX, touchY) {
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            const rect = joystick.getBoundingClientRect();
            
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = touchX - centerX;
            const dy = touchY - centerY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = rect.width / 2 - 20;
            
            let knobX = dx;
            let knobY = dy;
            
            if (distance > maxDistance) {
                knobX = (dx / distance) * maxDistance;
                knobY = (dy / distance) * maxDistance;
            }
            
            knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
            
            keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            
            if (distance > 20) {
                const angle = Math.atan2(dy, dx);
                
                if (angle > -Math.PI/4 && angle <= Math.PI/4) {
                    keys['d'] = true;
                } else if (angle > Math.PI/4 && angle <= 3*Math.PI/4) {
                    keys['s'] = true;
                } else if (angle > 3*Math.PI/4 || angle <= -3*Math.PI/4) {
                    keys['a'] = true;
                } else {
                    keys['w'] = true;
                }
            }
        }
        
        function gameLoop() {
            if (!game.paused) {
                if (game.mode === 'exploration') {
                    updateExploration();
                    autoSave();
                } else if (game.mode === 'combat') {
                    updateCombat();
                }
                
                updateUI();
                
                if (shakeAmount > 0) {
                    const shakeX = (Math.random() - 0.5) * shakeAmount;
                    const shakeY = (Math.random() - 0.5) * shakeAmount;
                    const currentTransform = canvas.style.transform;
                    canvas.style.transform = currentTransform + ` translate(${shakeX}px, ${shakeY}px)`;
                    shakeAmount *= 0.9;
                } else {
                    canvas.style.transform = 'translate(-50%, -50%)';
                }
                
                if (Date.now() - game.combat.lastHit > 2000) {
                    game.combat.combo = 0;
                    document.getElementById('comboCounter').style.display = 'none';
                }
                
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        generateWorld();
        checkDevModeStatus(); // Check if dev mode was previously unlocked
        
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('instructions').style.display = 'none';
            initializeMobileControls();
        }
        
        let helpShown = false;
        window.showQuickHelp = function() {
            if (!helpShown) {
                const quickHelp = document.getElementById('quickHelp');
                if (quickHelp) {
                    quickHelp.style.display = 'block';
                    setTimeout(() => {
                        quickHelp.style.display = 'none';
                    }, 5000);
                    helpShown = true;
                }
            }
        };
        
        if (saveMethod !== 'none' && getSaveInfo(1)) {
            const shouldLoad = confirm("Save file found! Load your progress?");
            if (shouldLoad) {
                loadGame(1);
            }
        }
        
        game.lastSaveTime = Date.now();
        gameLoop();
        
        // Welcome messages
        setTimeout(() => {
            if (saveMethod === 'memory') {
                showDialogue("Note: Browser storage blocked. Saves are temporary - download to keep them!");
            } else {
                showDialogue("Welcome to Sacred Valley. The path of a developer mirrors that of a sacred artist!");
            }
            
            // Show dev achievement after a delay
            setTimeout(() => {
                devTracker.showDevAchievement('Sacred Valley Dev Edition', 'Game + Dev Tracker Integration Complete!');
                devTracker.gainXP(50, 'Started development journey');
            }, 3000);
        }, 1000);

        // Make save functions global
        window.saveToSlot = saveToSlot;
        window.loadFromSlot = loadFromSlot;
        window.deleteSlot = deleteSlot;
        window.closeSaveMenu = closeSaveMenu;
    </script>
</body>
</html>
